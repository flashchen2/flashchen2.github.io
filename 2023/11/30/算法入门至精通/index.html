

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="张辰">
  <meta name="keywords" content="">
  
    <meta name="description" content="从零开始学算法">
<meta property="og:type" content="article">
<meta property="og:title" content="算法入门至精通">
<meta property="og:url" content="http://example.com/2023/11/30/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E8%87%B3%E7%B2%BE%E9%80%9A/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="从零开始学算法">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/algorithm_pic/1.jpg">
<meta property="article:published_time" content="2023-11-30T12:00:00.000Z">
<meta property="article:modified_time" content="2024-04-16T08:53:15.000Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="开发">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/algorithm_pic/1.jpg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>算法入门至精通 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.6","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/banner_hexo.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="算法入门至精通"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-11-30 20:00" pubdate>
          2023年11月30日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          9.4k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          79 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">算法入门至精通</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="一、复杂度分析"><a href="#一、复杂度分析" class="headerlink" title="一、复杂度分析"></a>一、复杂度分析</h1><p>学习链接：<a target="_blank" rel="noopener" href="https://www.hello-algo.com/">https://www.hello-algo.com/</a></p>
<h2 id="1-时间复杂度"><a href="#1-时间复杂度" class="headerlink" title="1. 时间复杂度"></a>1. 时间复杂度</h2><p>运行时间可以直观且准确地反映算法的效率。如果我们想准确预估一段代码的运行时间，应该如何操作呢？</p>
<ol>
<li><strong>确定运行平台</strong>，包括硬件配置、编程语言、系统环境等，这些因素都会影响代码的运行效率。</li>
<li><strong>评估各种计算操作所需的运行时间</strong>，例如加法操作 <code>+</code> 需要 1 ns ，乘法操作 <code>*</code> 需要 10 ns ，打印操作 <code>print()</code> 需要 5 ns 等。</li>
<li><strong>统计代码中所有的计算操作</strong>，并将所有操作的执行时间求和，从而得到运行时间。</li>
</ol>
<p>例如在以下代码中，输入数据大小为 n ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在某运行平台下</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">algorithm</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;  <span class="hljs-comment">// 1 ns</span><br>    a = a + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 1 ns</span><br>    a = a * <span class="hljs-number">2</span>;  <span class="hljs-comment">// 10 ns</span><br>    <span class="hljs-comment">// 循环 n 次</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;  <span class="hljs-comment">// 1 ns ，每轮都要执行 i++</span><br>        System.out.println(<span class="hljs-number">0</span>);     <span class="hljs-comment">// 5 ns</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>根据以上方法，可以得到算法的运行时间为 (6n+12) ns ：</p>
<center>1+1+10+(1+5)×n=6n+12</center>

<p>但实际上，<strong>统计算法的运行时间既不合理也不现实</strong>。首先，我们不希望将预估时间和运行平台绑定，因为算法需要在各种不同的平台上运行。其次，我们很难获知每种操作的运行时间，这给预估过程带来了极大的难度。</p>
<h3 id="1-统计时间增长趋势"><a href="#1-统计时间增长趋势" class="headerlink" title="1. 统计时间增长趋势"></a>1. 统计时间增长趋势</h3><p>时间复杂度分析统计的不是算法运行时间，<strong>而是算法运行时间随着数据量变大时的增长趋势</strong>。</p>
<p>“时间增长趋势”这个概念比较抽象，我们通过一个例子来加以理解。假设输入数据大小为 n ，给定三个算法 <code>A</code>、<code>B</code> 和 <code>C</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 算法 A 的时间复杂度：常数阶</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">algorithm_A</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    System.out.println(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-comment">// 算法 B 的时间复杂度：线性阶</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">algorithm_B</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        System.out.println(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 算法 C 的时间复杂度：常数阶</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">algorithm_C</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++) &#123;<br>        System.out.println(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>下图展示了以上三个算法函数的时间复杂度。</p>
<ul>
<li>算法 <code>A</code> 只有 1 个打印操作，算法运行时间不随着 n 增大而增长。我们称此算法的时间复杂度为“常数阶”。</li>
<li>算法 <code>B</code> 中的打印操作需要循环 n 次，算法运行时间随着 n 增大呈线性增长。此算法的时间复杂度被称为“线性阶”。</li>
<li>算法 <code>C</code> 中的打印操作需要循环 1000000 次，虽然运行时间很长，但它与输入数据大小 n 无关。因此 <code>C</code> 的时间复杂度和 <code>A</code> 相同，仍为“常数阶”。</li>
</ul>
<div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/9.png" srcset="/img/loading.gif" lazyload alt="图片描述">
</div>

<p>相较于直接统计算法的运行时间，时间复杂度分析有哪些特点呢？</p>
<ul>
<li><strong>时间复杂度能够有效评估算法效率</strong>。例如，算法 <code>B</code> 的运行时间呈线性增长，在 n&gt;1 时比算法 <code>A</code> 更慢，在 n&gt;1000000 时比算法 <code>C</code> 更慢。事实上，只要输入数据大小 n 足够大，复杂度为“常数阶”的算法一定优于“线性阶”的算法，这正是时间增长趋势的含义。</li>
<li><strong>时间复杂度的推算方法更简便</strong>。显然，运行平台和计算操作类型都与算法运行时间的增长趋势无关。因此在时间复杂度分析中，我们可以简单地将所有计算操作的执行时间视为相同的“单位时间”，从而将“计算操作运行时间统计”简化为“计算操作数量统计”，这样一来估算难度就大大降低了。</li>
<li><strong>时间复杂度也存在一定的局限性</strong>。例如，尽管算法 <code>A</code> 和 <code>C</code> 的时间复杂度相同，但实际运行时间差别很大。同样，尽管算法 <code>B</code> 的时间复杂度比 <code>C</code> 高，但在输入数据大小 n 较小时，算法 <code>B</code> 明显优于算法 <code>C</code> 。在这些情况下，我们很难仅凭时间复杂度判断算法效率的高低。当然，尽管存在上述问题，复杂度分析仍然是评判算法效率最有效且常用的方法。</li>
</ul>
<h3 id="2-函数渐近上界"><a href="#2-函数渐近上界" class="headerlink" title="2. 函数渐近上界"></a>2. 函数渐近上界</h3><p>给定一个输入大小为 n 的函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">algorithm</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">// +1</span><br>    a = a + <span class="hljs-number">1</span>;  <span class="hljs-comment">// +1</span><br>    a = a * <span class="hljs-number">2</span>;  <span class="hljs-comment">// +1</span><br>    <span class="hljs-comment">// 循环 n 次</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123; <span class="hljs-comment">// +1（每轮都执行 i ++）</span><br>        System.out.println(<span class="hljs-number">0</span>);    <span class="hljs-comment">// +1</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>设算法的操作数量是一个关于输入数据大小 n 的函数，记为 T(n) ，则以上函数的操作数量为：</p>
<center>T(n)=3+2n</center>

<p>T(n) 是一次函数，说明其运行时间的增长趋势是线性的，因此它的时间复杂度是线性阶。</p>
<p>我们将线性阶的时间复杂度记为 O(n) ，这个数学符号称为「大 O 记号 big-O notation」，表示函数 T(n) 的「渐近上界 asymptotic upper bound」。</p>
<p>时间复杂度分析本质上是计算“操作数量 T(n)”的渐近上界，它具有明确的数学定义。</p>
<ul>
<li><strong>函数渐近上界</strong></li>
</ul>
<p>若存在正实数 c 和实数 n<sub>0 </sub>，使得对于所有的 n&gt;n<sub>0</sub> ，均有 T(n)≤c⋅f(n) ，则可认为 f(n) 给出了 T(n) 的一个渐近上界，记为 T(n)&#x3D;O(f(n)) 。</p>
<p>如下图所示，计算渐近上界就是寻找一个函数 f(n) ，使得当 n 趋向于无穷大时，T(n) 和 f(n) 处于相同的增长级别，仅相差一个常数项 c 的倍数。</p>
<div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/10.png" srcset="/img/loading.gif" lazyload alt="图片描述">
</div>



<h3 id="3-推算方法"><a href="#3-推算方法" class="headerlink" title="3. 推算方法"></a>3. 推算方法</h3><ol>
<li><p><strong>时间复杂度由 T(n) 中最高阶的项来决定</strong>。这是因为在 n 趋于无穷大时，最高阶的项将发挥主导作用，其他项的影响都可以忽略。</p>
<p>例：</p>
<table>
<thead>
<tr>
<th>操作数量T(n)</th>
<th>时间复杂符O(f(n))</th>
</tr>
</thead>
<tbody><tr>
<td>100000</td>
<td>O(1)</td>
</tr>
<tr>
<td>3n + 2</td>
<td>O(n)</td>
</tr>
<tr>
<td>2n<sup>2</sup> + 3n + 2</td>
<td>O(n<sup>2</sup>)</td>
</tr>
<tr>
<td>n<sup>3</sup>+10000n<sup>2</sup></td>
<td>O(n<sup>3</sup>)</td>
</tr>
<tr>
<td>2<sup>n</sup> + 10000n<sup>10000</sup></td>
<td>O(2<sup>n</sup>)</td>
</tr>
</tbody></table>
</li>
<li><p>常见类型</p>
<p>O(1) &lt; O(log<sub>n</sub>) &lt; O(n) &lt; O(nlog<sub>n</sub>) &lt; O(n<sup>2</sup>) &lt;  O(2<sup>n</sup>) &lt; O(n!)</p>
<div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/3.png" srcset="/img/loading.gif" lazyload alt="图片描述">
</div></li>
</ol>
<h3 id="4-常见类型"><a href="#4-常见类型" class="headerlink" title="4. 常见类型"></a>4. 常见类型</h3><h4 id="1-常数阶O-1"><a href="#1-常数阶O-1" class="headerlink" title="1. 常数阶O(1)"></a>1. 常数阶O(1)</h4><p>常数阶的操作数量与输入数据大小n无关，即不随着n的变化而变化。</p>
<p>在以下函数中，尽管操作数量 <code>size</code> 可能很大，但由于其与输入数据大小n无关，因此时间复杂度仍为O(1) ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 常数阶 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">constant</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">100000</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++)<br>        count++;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="2-线性阶O-n"><a href="#2-线性阶O-n" class="headerlink" title="2. 线性阶O(n)"></a>2. 线性阶O(n)</h4><p>线性阶的操作数量相对于输入数据大小n以线性级别增长。线性阶通常出现在单层循环中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 线性阶 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">linear</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)<br>        count++;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>遍历数组和遍历链表等操作的时间复杂度均为O(n) ，其中n为数组或链表的长度：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 线性阶（遍历数组） */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">arrayTraversal</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 循环次数与数组长度成正比</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        count++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>值得注意的是，<strong>输入数据大小n需根据输入数据的类型来具体确定</strong>。比如在第一个示例中，变量n为输入数据大小；在第二个示例中，数组长度n为数据大小。</p>
<h4 id="3-平方阶O-n2"><a href="#3-平方阶O-n2" class="headerlink" title="3. 平方阶O(n2)"></a>3. 平方阶O(n<sup>2</sup>)</h4><p>平方阶的操作数量相对于输入数据大小n以平方级别增长。平方阶通常出现在嵌套循环中，外层循环和内层循环的时间复杂度都为O(n) ，因此总体的时间复杂度为O(n<sup>2</sup>) ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 平方阶 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">quadratic</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 循环次数与数组长度成平方关系</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            count++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>下图对比了常数阶、线性阶和平方阶三种时间复杂度。</p>
<div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/4.png" srcset="/img/loading.gif" lazyload alt="图片描述">
</div>



<p>以冒泡排序为例，外层循环执行 n−1 次，内层循环执行 n−1、n−2、…、2、1 次，平均为 n&#x2F;2 次，因此时间复杂度为 O((n−1)n&#x2F;2)&#x3D;O(n<sup>2</sup>) ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 平方阶（冒泡排序） */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">bubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 计数器</span><br>    <span class="hljs-comment">// 外循环：未排序区间为 [0, i]</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">// 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[j] &gt; nums[j + <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-comment">// 交换 nums[j] 与 nums[j + 1]</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> nums[j];<br>                nums[j] = nums[j + <span class="hljs-number">1</span>];<br>                nums[j + <span class="hljs-number">1</span>] = tmp;<br>                count += <span class="hljs-number">3</span>; <span class="hljs-comment">// 元素交换包含 3 个单元操作</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="5-指数阶O-2n"><a href="#5-指数阶O-2n" class="headerlink" title="5. 指数阶O(2n)"></a>5. 指数阶O(2<sup>n</sup>)</h4><p>生物学的“细胞分裂”是指数阶增长的典型例子：初始状态为 1 个细胞，分裂一轮后变为 2 个，分裂两轮后变为 4 个，以此类推，分裂 n 轮后有 2<sup>n</sup> 个细胞。</p>
<p>下和以下代码模拟了细胞分裂的过程，时间复杂度为 ）O(2<sup>n</sup>) ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 指数阶（循环实现） */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">exponential</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, base = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 细胞每轮一分为二，形成数列 1, 2, 4, 8, ..., 2^(n-1)</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; base; j++) &#123;<br>            count++;<br>        &#125;<br>        base *= <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-comment">// count = 1 + 2 + 4 + 8 + .. + 2^(n-1) = 2^n - 1</span><br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure>

<div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/5.png" srcset="/img/loading.gif" lazyload alt="图片描述">
</div>



<p>在实际算法中，指数阶常出现于递归函数中。例如在以下代码中，其递归地一分为二，经过n次分裂后停止：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 指数阶（递归实现） */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">expRecur</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> expRecur(n - <span class="hljs-number">1</span>) + expRecur(n - <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>指数阶增长非常迅速，在穷举法（暴力搜索、回溯等）中比较常见。对于数据规模较大的问题，指数阶是不可接受的，通常需要使用动态规划或贪心算法等来解决。</p>
<h4 id="6-对数阶O-logn"><a href="#6-对数阶O-logn" class="headerlink" title="6. 对数阶O(logn)"></a>6. 对数阶O(log<sub>n</sub>)</h4><p>与指数阶相反，对数阶反映了“每轮缩减到一半”的情况。设输入数据大小为n，由于每轮缩减到一半，因此循环次数是 log<sub>2</sub><sup>n</sup>，即 2<sup>n</sup> 的反函数。</p>
<p>下图和以下代码模拟了“每轮缩减到一半”的过程，时间复杂度为 O(log<sub>2</sub><sup>n</sup>) ，简记为 O(log⁡<sup>n</sup>) ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 对数阶（循环实现） */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">logarithmic</span><span class="hljs-params">(<span class="hljs-type">float</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">1</span>) &#123;<br>        n = n / <span class="hljs-number">2</span>;<br>        count++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure>

<div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/6.png" srcset="/img/loading.gif" lazyload alt="图片描述">
</div>

<p>与指数阶类似，对数阶也常出现于递归函数中。以下代码形成了一棵高度为 log<sub>2</sub><sup>⁡n</sup> 的递归树：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 对数阶（递归实现） */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">logRecur</span><span class="hljs-params">(<span class="hljs-type">float</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> logRecur(n / <span class="hljs-number">2</span>) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对数阶常出现于基于分治策略的算法中，体现了“一分为多”和“化繁为简”的算法思想。它增长缓慢，是仅次于常数阶的理想的时间复杂度。</p>
<h4 id="7-线性对数阶-O-nlog⁡n"><a href="#7-线性对数阶-O-nlog⁡n" class="headerlink" title="7. 线性对数阶 O(nlog⁡n)"></a>7. 线性对数阶 O(nlog⁡<sup>n</sup>)</h4><p>线性对数阶常出现于嵌套循环中，两层循环的时间复杂度分别为 O(log⁡<sup>n</sup>) 和 O(n) 。相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 线性对数阶 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">linearLogRecur</span><span class="hljs-params">(<span class="hljs-type">float</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> linearLogRecur(n / <span class="hljs-number">2</span>) + linearLogRecur(n / <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        count++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>下图展示了线性对数阶的生成方式。二叉树的每一层的操作总数都为n，树共有 log<sub>2</sub><sup>n</sup>+1 层，因此时间复杂度为 O(nlog⁡<sup>n</sup>) 。</p>
<div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/7.png" srcset="/img/loading.gif" lazyload alt="图片描述">
</div>

<p>主流排序算法的时间复杂度通常为 O(nlog⁡<sup>n</sup>) ，例如快速排序、归并排序、堆排序等。</p>
<h4 id="8-阶乘阶-O-n"><a href="#8-阶乘阶-O-n" class="headerlink" title="8.  阶乘阶 O(n!)"></a>8.  阶乘阶 O(n!)</h4><p>阶乘阶对应数学上的“全排列”问题。给定 n 个互不重复的元素，求其所有可能的排列方案，方案数量为：</p>
<center>n!=n×(n−1)×(n−2)×⋯×2×1</center>

<p>阶乘通常使用递归实现。如下图 和以下代码所示，第一层分裂出 n 个，第二层分裂出 n−1 个，以此类推，直至第 n 层时停止分裂：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 阶乘阶（递归实现） */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">factorialRecur</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 从 1 个分裂出 n 个</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        count += factorialRecur(n - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure>



<div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/8.png" srcset="/img/loading.gif" lazyload alt="图片描述">
</div>

<ul>
<li>请注意，因为当 n≥4 时恒有 n! &gt; 2<sup>n</sup> ，所以阶乘阶比指数阶增长得更快，在 n 较大时也是不可接受的。</li>
</ul>
<h3 id="5-最差、最佳、平均时间复杂度"><a href="#5-最差、最佳、平均时间复杂度" class="headerlink" title="5. 最差、最佳、平均时间复杂度"></a>5. 最差、最佳、平均时间复杂度</h3><p><strong>算法的时间效率往往不是固定的，而是与输入数据的分布有关</strong>。假设输入一个长度为 n 的数组 <code>nums</code> ，其中 <code>nums</code> 由从 1 至 n 的数字组成，每个数字只出现一次；但元素顺序是随机打乱的，任务目标是返回元素 1 的索引。我们可以得出以下结论。</p>
<ul>
<li>当 <code>nums = [?, ?, ..., 1]</code> ，即当末尾元素是 1 时，需要完整遍历数组，<strong>达到最差时间复杂度 O(n)</strong> 。</li>
<li>当 <code>nums = [1, ?, ?, ...]</code> ，即当首个元素为 1 时，无论数组多长都不需要继续遍历，<strong>达到最佳时间复杂度 Ω(1)</strong> 。</li>
</ul>
<p>“最差时间复杂度”对应函数渐近上界，使用大 O 记号表示。相应地，“最佳时间复杂度”对应函数渐近下界，用 Ω 记号表示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 生成一个数组，元素为 &#123; 1, 2, ..., n &#125;，顺序被打乱 */</span><br><span class="hljs-type">int</span>[] randomNumbers(<span class="hljs-type">int</span> n) &#123;<br>    Integer[] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[n];<br>    <span class="hljs-comment">// 生成数组 nums = &#123; 1, 2, 3, ..., n &#125;</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        nums[i] = i + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 随机打乱数组元素</span><br>    Collections.shuffle(Arrays.asList(nums));<br>    <span class="hljs-comment">// Integer[] -&gt; int[]</span><br>    <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        res[i] = nums[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">/* 查找数组 nums 中数字 1 所在索引 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">findOne</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-comment">// 当元素 1 在数组头部时，达到最佳时间复杂度 O(1)</span><br>        <span class="hljs-comment">// 当元素 1 在数组尾部时，达到最差时间复杂度 O(n)</span><br>        <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>值得说明的是，我们在实际中很少使用最佳时间复杂度，因为通常只有在很小概率下才能达到，可能会带来一定的误导性。<strong>而最差时间复杂度更为实用，因为它给出了一个效率安全值</strong>，让我们可以放心地使用算法。</p>
<p>从上述示例可以看出，最差时间复杂度和最佳时间复杂度只出现于“特殊的数据分布”，这些情况的出现概率可能很小，并不能真实地反映算法运行效率。相比之下，<strong>平均时间复杂度可以体现算法在随机输入数据下的运行效率</strong>，用 Θ 记号来表示。</p>
<p>对于部分算法，我们可以简单地推算出随机数据分布下的平均情况。比如上述示例，由于输入数组是被打乱的，因此元素 1 出现在任意索引的概率都是相等的，那么算法的平均循环次数就是数组长度的一半 n&#x2F;2 ，平均时间复杂度为 Θ(n&#x2F;2)&#x3D;Θ(n) 。</p>
<p>但对于较为复杂的算法，计算平均时间复杂度往往比较困难，因为很难分析出在数据分布下的整体数学期望。在这种情况下，我们通常使用最差时间复杂度作为算法效率的评判标准。</p>
<ul>
<li>为什么很少看到 Θ 符号？</li>
</ul>
<p>可能由于 O 符号过于朗朗上口，因此我们常常使用它来表示平均时间复杂度。但从严格意义上讲，这种做法并不规范。在本书和其他资料中，若遇到类似“平均时间复杂度 O(n)”的表述，请将其直接理解为 Θ(n) 。</p>
<h2 id="2-空间复杂度"><a href="#2-空间复杂度" class="headerlink" title="2.  空间复杂度"></a>2.  空间复杂度</h2><p>「空间复杂度 space complexity」用于衡量算法占用内存空间随着数据量变大时的增长趋势。这个概念与时间复杂度非常类似，只需将“运行时间”替换为“占用内存空间”。</p>
<h3 id="1-算法相关空间"><a href="#1-算法相关空间" class="headerlink" title="1.  算法相关空间"></a>1.  算法相关空间</h3><p>算法在运行过程中使用的内存空间主要包括以下几种。</p>
<ul>
<li><strong>输入空间</strong>：用于存储算法的输入数据。</li>
<li><strong>暂存空间</strong>：用于存储算法在运行过程中的变量、对象、函数上下文等数据。</li>
<li><strong>输出空间</strong>：用于存储算法的输出数据。</li>
</ul>
<p>一般情况下，空间复杂度的统计范围是“暂存空间”加上“输出空间”。</p>
<p>暂存空间可以进一步划分为三个部分。</p>
<ul>
<li><strong>暂存数据</strong>：用于保存算法运行过程中的各种常量、变量、对象等。</li>
<li><strong>栈帧空间</strong>：用于保存调用函数的上下文数据。系统在每次调用函数时都会在栈顶部创建一个栈帧，函数返回后，栈帧空间会被释放。</li>
<li><strong>指令空间</strong>：用于保存编译后的程序指令，在实际统计中通常忽略不计。</li>
</ul>
<p>在分析一段程序的空间复杂度时，<strong>我们通常统计暂存数据、栈帧空间和输出数据三部分</strong>，如下图所示。</p>
<div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/11.png" srcset="/img/loading.gif" lazyload alt="图片描述">
</div>

<p>相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 类 */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    Node next;<br>    Node(<span class="hljs-type">int</span> x) &#123; val = x; &#125;<br>&#125;<br><br><span class="hljs-comment">/* 函数 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">function</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 执行某些操作...</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">algorithm</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;        <span class="hljs-comment">// 输入数据</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;          <span class="hljs-comment">// 暂存数据（常量）</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;                <span class="hljs-comment">// 暂存数据（变量）</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 暂存数据（对象）</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> function();       <span class="hljs-comment">// 栈帧空间（调用函数）</span><br>    <span class="hljs-keyword">return</span> a + b + c;         <span class="hljs-comment">// 输出数据</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="2-推算方法"><a href="#2-推算方法" class="headerlink" title="2.  推算方法"></a>2.  推算方法</h3><p>空间复杂度的推算方法与时间复杂度大致相同，只需将统计对象从“操作数量”转为“使用空间大小”。</p>
<p>而与时间复杂度不同的是，<strong>我们通常只关注最差空间复杂度</strong>。这是因为内存空间是一项硬性要求，我们必须确保在所有输入数据下都有足够的内存空间预留。</p>
<p>观察以下代码，最差空间复杂度中的“最差”有两层含义。</p>
<ol>
<li><strong>以最差输入数据为准</strong>：当 n&lt;10 时，空间复杂度为 O(1) ；但当 n&gt;10 时，初始化的数组 <code>nums</code> 占用 O(n) 空间，因此最差空间复杂度为 O(n) </li>
<li><strong>以算法运行中的峰值内存为准</strong>：例如，程序在执行最后一行之前，占用 O(1) 空间；当初始化数组 <code>nums</code> 时，程序占用 O(n) 空间，因此最差空间复杂度为 O(n) 。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">algorithm</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;                   <span class="hljs-comment">// O(1)</span><br>    <span class="hljs-type">int</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10000</span>];    <span class="hljs-comment">// O(1)</span><br>    <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">10</span>)<br>        <span class="hljs-type">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n]; <span class="hljs-comment">// O(n)</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>在递归函数中，需要注意统计栈帧空间</strong>。观察以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">function</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 执行某些操作</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/* 循环 O(1) */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">loop</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        function();<br>    &#125;<br>&#125;<br><span class="hljs-comment">/* 递归 O(n) */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">recur</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">return</span> recur(n - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>函数 <code>loop()</code> 和 <code>recur()</code> 的时间复杂度都为 O(n) ，但空间复杂度不同。</p>
<ul>
<li>函数 <code>loop()</code> 在循环中调用了 n 次 <code>function()</code> ，每轮中的 <code>function()</code> 都返回并释放了栈帧空间，因此空间复杂度仍为 O(1) 。</li>
<li>递归函数 <code>recur()</code> 在运行过程中会同时存在 n 个未返回的 <code>recur()</code> ，从而占用 O(n) 的栈帧空间。</li>
</ul>
<h3 id="3-常见类型"><a href="#3-常见类型" class="headerlink" title="3. 常见类型"></a>3. 常见类型</h3><p>设输入数据大小为 n ，下图展示了常见的空间复杂度类型（从低到高排列）。</p>
<center>O(1) < O(log<sub>n</sub>) < O(n) < O(n<sub>2</sub>) < O(2<sup>n</sup>)</center>

<center>常数阶 < 对数阶 < 线性阶 < 平方阶 < 指数阶</center>

<div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/12.png" srcset="/img/loading.gif" lazyload alt="图片描述">
</div>


<h4 id="1-常数阶-O-1"><a href="#1-常数阶-O-1" class="headerlink" title="1.常数阶 O(1)"></a>1.常数阶 O(1)</h4><p>常数阶常见于数量与输入数据大小 n 无关的常量、变量、对象。</p>
<p>需要注意的是，在循环中初始化变量或调用函数而占用的内存，在进入下一循环后就会被释放，因此不会累积占用空间，空间复杂度仍为 O(1) ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 函数 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">function</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 执行某些操作</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 常数阶 */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">constant</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-comment">// 常量、变量、对象占用 O(1) 空间</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10000</span>];<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 循环中的变量占用 O(1) 空间</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// 循环中的函数占用 O(1) 空间</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        function();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="2-线性阶-O-n"><a href="#2-线性阶-O-n" class="headerlink" title="2.线性阶 O(n)"></a>2.线性阶 O(n)</h4><p>线性阶常见于元素数量与 n 成正比的数组、链表、栈、队列等：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 线性阶 */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">linear</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-comment">// 长度为 n 的数组占用 O(n) 空间</span><br>    <span class="hljs-type">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    <span class="hljs-comment">// 长度为 n 的列表占用 O(n) 空间</span><br>    List&lt;ListNode&gt; nodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        nodes.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(i));<br>    &#125;<br>    <span class="hljs-comment">// 长度为 n 的哈希表占用 O(n) 空间</span><br>    Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        map.put(i, String.valueOf(i));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如下图所示，此函数的递归深度为 n ，即同时存在 n 个未返回的 <code>linear_recur()</code> 函数，使用 O(n) 大小的栈帧空间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 线性阶（递归实现） */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">linearRecur</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;递归 n = &quot;</span> + n);<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span>;<br>    linearRecur(n - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/13.png" srcset="/img/loading.gif" lazyload alt="图片描述">
</div>



<h4 id="3-平方阶-O-n2"><a href="#3-平方阶-O-n2" class="headerlink" title="3. 平方阶 O(n2)"></a>3. 平方阶 O(n<sup>2</sup>)</h4><p>平方阶常见于矩阵和图，元素数量与 n 成平方关系：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 平方阶 */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">quadratic</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-comment">// 矩阵占用 O(n^2) 空间</span><br>    <span class="hljs-type">int</span>[][] numMatrix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>    <span class="hljs-comment">// 二维列表占用 O(n^2) 空间</span><br>    List&lt;List&lt;Integer&gt;&gt; numList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            tmp.add(<span class="hljs-number">0</span>);<br>        &#125;<br>        numList.add(tmp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如下图所示，该函数的递归深度为 n ，在每个递归函数中都初始化了一个数组，长度分别为 n、n−1、…、2、1 ，平均长度为 n&#x2F;2 ，因此总体占用 O(n<sup>2</sup>) 空间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 平方阶（递归实现） */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">quadraticRecur</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 数组 nums 长度为 n, n-1, ..., 2, 1</span><br>    <span class="hljs-type">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    System.out.println(<span class="hljs-string">&quot;递归 n = &quot;</span> + n + <span class="hljs-string">&quot; 中的 nums 长度 = &quot;</span> + nums.length);<br>    <span class="hljs-keyword">return</span> quadraticRecur(n - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>



<div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/14.png" srcset="/img/loading.gif" lazyload alt="图片描述">
</div>



<h4 id="4-指数阶-O-2n"><a href="#4-指数阶-O-2n" class="headerlink" title="4.指数阶 O(2n)"></a>4.指数阶 O(2<sup>n</sup>)</h4><p>指数阶常见于二叉树。观察下图 ，层数为 n 的“满二叉树”的节点数量为 2<sup>n</sup>−1 ，占用 O(2<sup>n</sup>) 空间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 指数阶（建立满二叉树） */</span><br>TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">0</span>);<br>    root.left = buildTree(n - <span class="hljs-number">1</span>);<br>    root.right = buildTree(n - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure>

<div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/15.png" srcset="/img/loading.gif" lazyload alt="图片描述">
</div>



<h4 id="5-对数阶-O-logn⁡"><a href="#5-对数阶-O-logn⁡" class="headerlink" title="5. 对数阶 O(logn⁡)"></a>5. 对数阶 O(log<sub>n</sub>⁡)</h4><p>对数阶常见于分治算法。例如归并排序，输入长度为 n 的数组，每轮递归将数组从中点处划分为两半，形成高度为 log⁡<sub>n</sub> 的递归树，使用 O(log⁡<sub>n</sub>) 栈帧空间。</p>
<p>再例如将数字转化为字符串，输入一个正整数 n ，它的位数为 ⌊log<sub>10</sub><sup>⁡n</sup>⌋+1 ，即对应字符串长度为 ⌊log<sub>10</sub><sup>⁡n</sup>⌋+1 ，因此空间复杂度为 O(log<sub>10</sub><sup>⁡n</sup>+1)&#x3D;O(log⁡<sub>n</sub>) 。</p>
<h4 id="6-权衡时间与空间"><a href="#6-权衡时间与空间" class="headerlink" title="6. 权衡时间与空间"></a>6. 权衡时间与空间</h4><p>理想情况下，我们希望算法的时间复杂度和空间复杂度都能达到最优。然而在实际情况中，同时优化时间复杂度和空间复杂度通常非常困难。</p>
<p><strong>降低时间复杂度通常需要以提升空间复杂度为代价，反之亦然</strong>。我们将牺牲内存空间来提升算法运行速度的思路称为“以空间换时间”；反之，则称为“以时间换空间”。</p>
<p>选择哪种思路取决于我们更看重哪个方面。在大多数情况下，<mark>时间比空间更宝贵</mark>，因此“以空间换时间”通常是更常用的策略。当然，在数据量很大的情况下，控制空间复杂度也非常重要。</p>
<h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><h3 id="1-重点回顾"><a href="#1-重点回顾" class="headerlink" title="1.  重点回顾"></a>1.  重点回顾</h3><p><strong>算法效率评估</strong></p>
<ul>
<li>时间效率和空间效率是衡量算法优劣的两个主要评价指标。</li>
<li>我们可以通过实际测试来评估算法效率，但难以消除测试环境的影响，且会耗费大量计算资源。</li>
<li>复杂度分析可以消除实际测试的弊端，分析结果适用于所有运行平台，并且能够揭示算法在不同数据规模下的效率。</li>
</ul>
<p><strong>时间复杂度</strong></p>
<ul>
<li>时间复杂度用于衡量算法运行时间随数据量增长的趋势，可以有效评估算法效率，但在某些情况下可能失效，如在输入的数据量较小或时间复杂度相同时，无法精确对比算法效率的优劣。</li>
<li>最差时间复杂度使用大 O 符号表示，对应函数渐近上界，反映当 n 趋向正无穷时，操作数量 T(n) 的增长级别。</li>
<li>推算时间复杂度分为两步，首先统计操作数量，然后判断渐近上界。</li>
<li>常见时间复杂度从低到高排列有 O(1)、O(log⁡<sub>n</sub>)、O(n)、O(nlog⁡<sub>n</sub>)、O(n<sup>2</sup>)、O(2<sup>n</sup>) 和 O(n!) 等。</li>
<li>某些算法的时间复杂度非固定，而是与输入数据的分布有关。时间复杂度分为最差、最佳、平均时间复杂度，最佳时间复杂度几乎不用，因为输入数据一般需要满足严格条件才能达到最佳情况。</li>
<li>平均时间复杂度反映算法在随机数据输入下的运行效率，最接近实际应用中的算法性能。计算平均时间复杂度需要统计输入数据分布以及综合后的数学期望。</li>
</ul>
<p><strong>空间复杂度</strong></p>
<ul>
<li>空间复杂度的作用类似于时间复杂度，用于衡量算法占用内存空间随数据量增长的趋势。</li>
<li>算法运行过程中的相关内存空间可分为输入空间、暂存空间、输出空间。通常情况下，输入空间不纳入空间复杂度计算。暂存空间可分为暂存数据、栈帧空间和指令空间，其中栈帧空间通常仅在递归函数中影响空间复杂度。</li>
<li>我们通常只关注最差空间复杂度，即统计算法在最差输入数据和最差运行时刻下的空间复杂度。</li>
<li>常见空间复杂度从低到高排列有 O(1)、O(log⁡<sub>n</sub>)、O(n)、O(n<sup>2</sup>) 和 O(2<sup>n</sup>) 等。</li>
</ul>
<h3 id="2-Q-A"><a href="#2-Q-A" class="headerlink" title="2.  Q &amp; A"></a>2.  Q &amp; A</h3><p><strong>Q</strong>：尾递归的空间复杂度是 O(1) 吗？</p>
<p>理论上，尾递归函数的空间复杂度可以优化至 O(1) 。不过绝大多数编程语言（例如 Java、Python、C++、Go、C# 等）不支持自动优化尾递归，因此通常认为空间复杂度是 O(n) 。</p>
<p><strong>Q</strong>：函数和方法这两个术语的区别是什么？</p>
<p>「函数 function」可以被独立执行，所有参数都以显式传递。「方法 method」与一个对象关联，被隐式传递给调用它的对象，能够对类的实例中包含的数据进行操作。</p>
<p>下面以几种常见的编程语言为例来说明。</p>
<ul>
<li>C 语言是过程式编程语言，没有面向对象的概念，所以只有函数。但我们可以通过创建结构体（struct）来模拟面向对象编程，与结构体相关联的函数就相当于其他编程语言中的方法。</li>
<li>Java 和 C# 是面向对象的编程语言，代码块（方法）通常作为某个类的一部分。静态方法的行为类似于函数，因为它被绑定在类上，不能访问特定的实例变量。</li>
<li>C++ 和 Python 既支持过程式编程（函数），也支持面向对象编程（方法）。</li>
</ul>
<h1 id="二、数据结构"><a href="#二、数据结构" class="headerlink" title="二、数据结构"></a>二、数据结构</h1><h2 id="1-线性与非线性"><a href="#1-线性与非线性" class="headerlink" title="1. 线性与非线性"></a>1. 线性与非线性</h2><p><strong>逻辑结构揭示了数据元素之间的逻辑关系</strong>。在数组和链表中，数据按照一定顺序排列，体现了数据之间的线性关系；而在树中，数据从顶部向下按层次排列，表现出“祖先”与“后代”之间的派生关系；图则由节点和边构成，反映了复杂的网络关系。</p>
<p>如下图所示，逻辑结构可分为“线性”和“非线性”两大类。线性结构比较直观，指数据在逻辑关系上呈线性排列；非线性结构则相反，呈非线性排列。</p>
<ul>
<li><strong>线性数据结构</strong>：数组、链表、栈、队列、哈希表，元素之间是一对一的顺序关系。</li>
<li><strong>非线性数据结构</strong>：树、堆、图、哈希表。</li>
</ul>
<p>非线性数据结构可以进一步划分为树形结构和网状结构。</p>
<ul>
<li><strong>树形结构</strong>：树、堆、哈希表，元素之间是一对多的关系。</li>
<li><strong>网状结构</strong>：图，元素之间是多对多的关系。</li>
</ul>
<div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/16.png" srcset="/img/loading.gif" lazyload alt="图片描述">
</div>


<h1 id="三、数组与链表"><a href="#三、数组与链表" class="headerlink" title="三、数组与链表"></a>三、数组与链表</h1><h2 id="1-数组"><a href="#1-数组" class="headerlink" title="1. 数组"></a>1. 数组</h2><div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/17.png" srcset="/img/loading.gif" lazyload alt="图片描述" style="zoom:50%">
</div>



<h3 id="1-数组常用操作"><a href="#1-数组常用操作" class="headerlink" title="1.  数组常用操作"></a>1.  数组常用操作</h3><h4 id="1-初始化数组"><a href="#1-初始化数组" class="headerlink" title="1.  初始化数组"></a>1.  初始化数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 无初始值，默认初始化为0</span><br><span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">5</span>]; <span class="hljs-comment">// &#123; 0, 0, 0, 0, 0 &#125;</span><br><span class="hljs-comment">// 给定初始值</span><br><span class="hljs-type">int</span>[] nums = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span> &#125;;<br></code></pre></td></tr></table></figure>



<h4 id="2-访问元素"><a href="#2-访问元素" class="headerlink" title="2.  访问元素"></a>2.  访问元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 整型数组</span><br><span class="hljs-type">int</span>[] array1 = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> array1[<span class="hljs-number">2</span>];<br>System.out.println(a);   <span class="hljs-comment">// 3</span><br><br><span class="hljs-comment">// 字符串形式数组</span><br>String[] array2 = &#123;<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>&#125;;<br><span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> array2[<span class="hljs-number">2</span>];<br>System.out.println(b);  <span class="hljs-comment">// c</span><br><br><span class="hljs-comment">// 循环取值</span><br>String[] array3 = &#123;<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array3.length ; i++) &#123;<br>    System.out.print(array3[i]);    <span class="hljs-comment">// abcde</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="3-添加元素"><a href="#3-添加元素" class="headerlink" title="3. 添加元素"></a>3. 添加元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test12</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;      <span class="hljs-comment">// 逻辑大小</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">capacity</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;  <span class="hljs-comment">// 容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] arry = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[capacity];  <span class="hljs-comment">// 创建静态数组</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addList</span><span class="hljs-params">(<span class="hljs-type">int</span> element)</span>&#123;<br>        arry[size] = element;<br>        size++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="3-插入元素"><a href="#3-插入元素" class="headerlink" title="3. 插入元素"></a>3. 插入元素</h4><p>如果想在数组中间插入一个元素，则需要将该元素之后的所有元素都向后移动一位，之后再把元素赋值给该索引。</p>
<div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/19.png" srcset="/img/loading.gif" lazyload alt="图片描述" style="zoom:50%">
</div>


<p>值得注意的是，由于数组的长度是固定的，因此插入一个元素必定会导致数组尾部元素“丢失”。我们将这个问题的解决方案留在“列表”章节中讨论。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 在数组的索引 index 处插入元素 num */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> num, <span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-comment">// 把索引 index 以及之后的所有元素向后移动一位</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>; i &gt; index; i--) &#123;<br>        nums[i] = nums[i - <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-comment">// 将 num 赋给 index 处的元素</span><br>    nums[index] = num;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="4-删除元素"><a href="#4-删除元素" class="headerlink" title="4. 删除元素"></a>4. 删除元素</h4><p>如下图所示，若想删除索引 i 处的元素，则需要把索引 i 之后的元素都向前移动一位。</p>
<div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/19.png" srcset="/img/loading.gif" lazyload alt="图片描述">
</div>

<p>请注意，删除元素完成后，原先末尾的元素变得“无意义”了，所以我们无须特意去修改它。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 删除索引 index 处的元素 */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-comment">// 把索引 index 之后的所有元素向前移动一位</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index; i &lt; nums.length - <span class="hljs-number">1</span>; i++) &#123;<br>        nums[i] = nums[i + <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>总的来看，数组的插入与删除操作有以下缺点。</p>
<ul>
<li><strong>时间复杂度高</strong>：数组的插入和删除的平均时间复杂度均为 O(n) ，其中 n 为数组长度。</li>
<li><strong>丢失元素</strong>：由于数组的长度不可变，因此在插入元素后，超出数组长度范围的元素会丢失。</li>
<li><strong>内存浪费</strong>：我们可以初始化一个比较长的数组，只用前面一部分，这样在插入数据时，丢失的末尾元素都是“无意义”的，但这样做会造成部分内存空间浪费。</li>
</ul>
<h4 id="5-遍历数组"><a href="#5-遍历数组" class="headerlink" title="5. 遍历数组"></a>5. 遍历数组</h4><p>在大多数编程语言中，我们既可以通过索引遍历数组，也可以直接遍历获取数组中的每个元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 遍历数组 */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">traverse</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 通过索引遍历数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        count += nums[i];<br>    &#125;<br>    <span class="hljs-comment">// 直接遍历数组元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        count += num;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="6-查找元素"><a href="#6-查找元素" class="headerlink" title="6.  查找元素"></a>6.  查找元素</h4><p>在数组中查找指定元素需要遍历数组，每轮判断元素值是否匹配，若匹配则输出对应索引。</p>
<p>因为数组是线性数据结构，所以上述查找操作被称为“线性查找”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 在数组中查找指定元素 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] == target)<br>            <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="7-扩容数组"><a href="#7-扩容数组" class="headerlink" title="7. 扩容数组"></a>7. 扩容数组</h4><p>在复杂的系统环境中，程序难以保证数组之后的内存空间是可用的，从而无法安全地扩展数组容量。因此在大多数编程语言中，<strong>数组的长度是不可变的</strong>。</p>
<p>如果我们希望扩容数组，则需重新建立一个更大的数组，然后把原数组元素依次复制到新数组。这是一个 O(n) 的操作，在数组很大的情况下非常耗时。代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 扩展数组长度 */</span><br><span class="hljs-type">int</span>[] extend(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> enlarge) &#123;<br>    <span class="hljs-comment">// 初始化一个扩展长度后的数组</span><br>    <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length + enlarge];<br>    <span class="hljs-comment">// 将原数组中的所有元素复制到新数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        res[i] = nums[i];<br>    &#125;<br>    <span class="hljs-comment">// 返回扩展后的新数组</span><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="2-数组的优点与局限性"><a href="#2-数组的优点与局限性" class="headerlink" title="2. 数组的优点与局限性"></a>2. 数组的优点与局限性</h3><p>数组存储在连续的内存空间内，且元素类型相同。这种做法包含丰富的先验信息，系统可以利用这些信息来优化数据结构的操作效率。</p>
<ul>
<li><strong>空间效率高</strong>：数组为数据分配了连续的内存块，无须额外的结构开销。</li>
<li><strong>支持随机访问</strong>：数组允许在 O(1) 时间内访问任何元素。</li>
<li><strong>缓存局部性</strong>：当访问数组元素时，计算机不仅会加载它，还会缓存其周围的其他数据，从而借助高速缓存来提升后续操作的执行速度。</li>
</ul>
<p>连续空间存储是一把双刃剑，其存在以下局限性。</p>
<ul>
<li><strong>插入与删除效率低</strong>：当数组中元素较多时，插入与删除操作需要移动大量的元素。</li>
<li><strong>长度不可变</strong>：数组在初始化后长度就固定了，扩容数组需要将所有数据复制到新数组，开销很大。</li>
<li><strong>空间浪费</strong>：如果数组分配的大小超过实际所需，那么多余的空间就被浪费了。</li>
</ul>
<h3 id="3-数组典型应用"><a href="#3-数组典型应用" class="headerlink" title="3. 数组典型应用"></a>3. 数组典型应用</h3><p>数组是一种基础且常见的数据结构，既频繁应用在各类算法之中，也可用于实现各种复杂数据结构。</p>
<ul>
<li><strong>随机访问</strong>：如果我们想随机抽取一些样本，那么可以用数组存储，并生成一个随机序列，根据索引实现随机抽样。</li>
<li><strong>排序和搜索</strong>：数组是排序和搜索算法最常用的数据结构。快速排序、归并排序、二分查找等都主要在数组上进行。</li>
<li><strong>查找表</strong>：当需要快速查找一个元素或其对应关系时，可以使用数组作为查找表。假如我们想实现字符到 ASCII 码的映射，则可以将字符的 ASCII 码值作为索引，对应的元素存放在数组中的对应位置。</li>
<li><strong>机器学习</strong>：神经网络中大量使用了向量、矩阵、张量之间的线性代数运算，这些数据都是以数组的形式构建的。数组是神经网络编程中最常使用的数据结构。</li>
<li><strong>数据结构实现</strong>：数组可以用于实现栈、队列、哈希表、堆、图等数据结构。例如，图的邻接矩阵表示实际上是一个二维数组。</li>
</ul>
<h2 id="2-链表"><a href="#2-链表" class="headerlink" title="2. 链表"></a>2. 链表</h2><p>内存空间是所有程序的公共资源，在一个复杂的系统运行环境下，空闲的内存空间可能散落在内存各处。我们知道，存储数组的内存空间必须是连续的，而当数组非常大时，内存可能无法提供如此大的连续空间。此时链表的灵活性优势就体现出来了。</p>
<p>「链表 linked list」是一种线性数据结构，其中的每个元素都是一个节点对象，各个节点通过“引用”相连接。引用记录了下一个节点的内存地址，通过它可以从当前节点访问到下一个节点。</p>
<p>链表的设计使得各个节点可以分散存储在内存各处，它们的内存地址无须连续。</p>
<div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/21.png" srcset="/img/loading.gif" lazyload alt="图片描述">
</div>

<p>如上图所示，链表的组成单位是「节点 node」对象。每个节点都包含两项数据：节点的“值”和指向下一节点的“引用”。</p>
<ul>
<li>链表的首个节点被称为“头节点”，最后一个节点被称为“尾节点”。</li>
<li>尾节点指向的是“空”，它在 Java、C++ 和 Python 中分别被记为 <code>null</code>、<code>nullptr</code> 和 <code>None</code> 。</li>
<li>在 C、C++、Go 和 Rust 等支持指针的语言中，上述“引用”应被替换为“指针”。</li>
</ul>
<p>如以下代码所示，链表节点 <code>ListNode</code> 除了包含值，还需额外保存一个引用（指针）。因此在相同数据量下，<strong>链表比数组占用更多的内存空间</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 链表节点类 */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-type">int</span> val;        <span class="hljs-comment">// 节点值</span><br>    ListNode next;  <span class="hljs-comment">// 指向下一节点的引用</span><br>    ListNode(<span class="hljs-type">int</span> x) &#123; val = x; &#125;  <span class="hljs-comment">// 构造函数</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="1-链表常用操作"><a href="#1-链表常用操作" class="headerlink" title="1.  链表常用操作"></a>1.  链表常用操作</h3><h4 id="1-初始化链表"><a href="#1-初始化链表" class="headerlink" title="1.  初始化链表"></a>1.  初始化链表</h4><p>建立链表分为两步，第一步是初始化各个节点对象，第二步是构建节点之间的引用关系。初始化完成后，我们就可以从链表的头节点出发，通过引用指向 <code>next</code> 依次访问所有节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 初始化链表 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4 */</span><br><span class="hljs-comment">// 初始化各个节点</span><br><span class="hljs-type">ListNode</span> <span class="hljs-variable">n0</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">1</span>);<br><span class="hljs-type">ListNode</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">3</span>);<br><span class="hljs-type">ListNode</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">2</span>);<br><span class="hljs-type">ListNode</span> <span class="hljs-variable">n3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">5</span>);<br><span class="hljs-type">ListNode</span> <span class="hljs-variable">n4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">4</span>);<br><span class="hljs-comment">// 构建节点之间的引用</span><br>n0.next = n1;<br>n1.next = n2;<br>n2.next = n3;<br>n3.next = n4;<br></code></pre></td></tr></table></figure>

<p>数组整体是一个变量，比如数组 <code>nums</code> 包含元素 <code>nums[0]</code> 和 <code>nums[1]</code> 等，而链表是由多个独立的节点对象组成的。<strong>我们通常将头节点当作链表的代称</strong>，比如以上代码中的链表可记作链表 <code>n0</code> 。</p>
<h4 id="2-插入节点"><a href="#2-插入节点" class="headerlink" title="2.  插入节点"></a>2.  插入节点</h4><p>在链表中插入节点非常容易。如图 4-6 所示，假设我们想在相邻的两个节点 <code>n0</code> 和 <code>n1</code> 之间插入一个新节点 <code>P</code> ，<strong>则只需改变两个节点引用（指针）即可</strong>，时间复杂度为 O(1) 。</p>
<p>相比之下，在数组中插入元素的时间复杂度为 O(n) ，在大数据量下的效率较低。</p>
<div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/22.png" srcset="/img/loading.gif" lazyload alt="图片描述">
</div>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 在链表的节点 n0 之后插入节点 P */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(ListNode n0, ListNode P)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> n0.next;<br>    P.next = n1;<br>    n0.next = P;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="3-删除节点"><a href="#3-删除节点" class="headerlink" title="3.  删除节点"></a>3.  删除节点</h4><p>如下图所示，在链表中删除节点也非常方便，<strong>只需改变一个节点的引用（指针）即可</strong>。</p>
<p>请注意，尽管在删除操作完成后节点 <code>P</code> 仍然指向 <code>n1</code> ，但实际上遍历此链表已经无法访问到 <code>P</code> ，这意味着 <code>P</code> 已经不再属于该链表了。</p>
<div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/23.png" srcset="/img/loading.gif" lazyload alt="图片描述">
</div>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 删除链表的节点 n0 之后的首个节点 */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(ListNode n0)</span> &#123;<br>    <span class="hljs-keyword">if</span> (n0.next == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// n0 -&gt; P -&gt; n1</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">P</span> <span class="hljs-operator">=</span> n0.next;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> P.next;<br>    n0.next = n1;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="4-访问节点"><a href="#4-访问节点" class="headerlink" title="4.  访问节点"></a>4.  访问节点</h4><p><strong>在链表中访问节点的效率较低</strong>。如上一节所述，我们可以在 O(1) 时间下访问数组中的任意元素。链表则不然，程序需要从头节点出发，逐个向后遍历，直至找到目标节点。也就是说，访问链表的第 i 个节点需要循环 i−1 轮，时间复杂度为 O(n) 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 访问链表中索引为 index 的节点 */</span><br>ListNode <span class="hljs-title function_">access</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; index; i++) &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        head = head.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="5-查找节点"><a href="#5-查找节点" class="headerlink" title="5.  查找节点"></a>5.  查找节点</h4><p>遍历链表，查找其中值为 <code>target</code> 的节点，输出该节点在链表中的索引。此过程也属于线性查找。代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 在链表中查找值为 target 的首个节点 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (head.val == target)<br>            <span class="hljs-keyword">return</span> index;<br>        head = head.next;<br>        index++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="2-数组-vs-链表"><a href="#2-数组-vs-链表" class="headerlink" title="2.  数组 vs. 链表"></a>2.  数组 vs. 链表</h3><p>下表总结了数组和链表的各项特点并对比了操作效率。由于它们采用两种相反的存储策略，因此各种性质和操作效率也呈现对立的特点。</p>
<center>数组与链表的效率对比</center>

<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">数组</th>
<th align="left">链表</th>
</tr>
</thead>
<tbody><tr>
<td align="left">存储方式</td>
<td align="left">连续内存空间</td>
<td align="left">分散内存空间</td>
</tr>
<tr>
<td align="left">容量扩展</td>
<td align="left">长度不可变</td>
<td align="left">可灵活扩展</td>
</tr>
<tr>
<td align="left">内存效率</td>
<td align="left">元素占用内存少、但可能浪费空间</td>
<td align="left">元素占用内存多</td>
</tr>
<tr>
<td align="left">访问元素</td>
<td align="left">O(1)</td>
<td align="left">O(n)</td>
</tr>
<tr>
<td align="left">添加元素</td>
<td align="left">O(n)</td>
<td align="left">O(1)</td>
</tr>
<tr>
<td align="left">删除元素</td>
<td align="left">O(n)</td>
<td align="left">O(1)</td>
</tr>
</tbody></table>
<h3 id="3-常见链表类型"><a href="#3-常见链表类型" class="headerlink" title="3.  常见链表类型"></a>3.  常见链表类型</h3><p>如下图所示，常见的链表类型包括三种。</p>
<ul>
<li><strong>单向链表</strong>：即前面介绍的普通链表。单向链表的节点包含值和指向下一节点的引用两项数据。我们将首个节点称为头节点，将最后一个节点称为尾节点，尾节点指向空 <code>None</code> 。</li>
<li><strong>环形链表</strong>：如果我们令单向链表的尾节点指向头节点（首尾相接），则得到一个环形链表。在环形链表中，任意节点都可以视作头节点。</li>
<li><strong>双向链表</strong>：与单向链表相比，双向链表记录了两个方向的引用。双向链表的节点定义同时包含指向后继节点（下一个节点）和前驱节点（上一个节点）的引用（指针）。相较于单向链表，双向链表更具灵活性，可以朝两个方向遍历链表，但相应地也需要占用更多的内存空间。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 双向链表节点类 */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-type">int</span> val;        <span class="hljs-comment">// 节点值</span><br>    ListNode next;  <span class="hljs-comment">// 指向后继节点的引用</span><br>    ListNode prev;  <span class="hljs-comment">// 指向前驱节点的引用</span><br>    ListNode(<span class="hljs-type">int</span> x) &#123; val = x; &#125;  <span class="hljs-comment">// 构造函数</span><br>&#125;<br></code></pre></td></tr></table></figure>

<div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/24.png" srcset="/img/loading.gif" lazyload alt="图片描述">
</div>



<h3 id="4-链表典型应用"><a href="#4-链表典型应用" class="headerlink" title="4.  链表典型应用"></a>4.  链表典型应用</h3><p>单向链表通常用于实现栈、队列、哈希表和图等数据结构。</p>
<ul>
<li><strong>栈与队列</strong>：当插入和删除操作都在链表的一端进行时，它表现出先进后出的特性，对应栈；当插入操作在链表的一端进行，删除操作在链表的另一端进行，它表现出先进先出的特性，对应队列。</li>
<li><strong>哈希表</strong>：链式地址是解决哈希冲突的主流方案之一，在该方案中，所有冲突的元素都会被放到一个链表中。</li>
<li><strong>图</strong>：邻接表是表示图的一种常用方式，其中图的每个顶点都与一个链表相关联，链表中的每个元素都代表与该顶点相连的其他顶点。</li>
</ul>
<p>双向链表常用于需要快速查找前一个和后一个元素的场景。</p>
<ul>
<li><strong>高级数据结构</strong>：比如在红黑树、B 树中，我们需要访问节点的父节点，这可以通过在节点中保存一个指向父节点的引用来实现，类似于双向链表。</li>
<li><strong>浏览器历史</strong>：在网页浏览器中，当用户点击前进或后退按钮时，浏览器需要知道用户访问过的前一个和后一个网页。双向链表的特性使得这种操作变得简单。</li>
<li><strong>LRU 算法</strong>：在缓存淘汰（LRU）算法中，我们需要快速找到最近最少使用的数据，以及支持快速添加和删除节点。这时候使用双向链表就非常合适。</li>
</ul>
<p>环形链表常用于需要周期性操作的场景，比如操作系统的资源调度。</p>
<ul>
<li><strong>时间片轮转调度算法</strong>：在操作系统中，时间片轮转调度算法是一种常见的 CPU 调度算法，它需要对一组进程进行循环。每个进程被赋予一个时间片，当时间片用完时，CPU 将切换到下一个进程。这种循环操作可以通过环形链表来实现。</li>
<li><strong>数据缓冲区</strong>：在某些数据缓冲区的实现中，也可能会使用环形链表。比如在音频、视频播放器中，数据流可能会被分成多个缓冲块并放入一个环形链表，以便实现无缝播放。</li>
</ul>
<h1 id="十、搜索"><a href="#十、搜索" class="headerlink" title="十、搜索"></a>十、搜索</h1><h2 id="2-二分查找"><a href="#2-二分查找" class="headerlink" title="2. 二分查找"></a>2. 二分查找</h2><p>二分查找算法也称折半查找，是一种非常高效的工作于有序数组的查找算法。后续的课程中还会学习更多的查找算法，但在此之前，不妨用它作为入门。</p>
<h3 id="1-需求说明"><a href="#1-需求说明" class="headerlink" title="1. 需求说明"></a>1. 需求说明</h3><div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/2.png" srcset="/img/loading.gif" lazyload alt="图片描述">
</div>


<h3 id="2-java实现"><a href="#2-java实现" class="headerlink" title="2. java实现"></a>2. java实现</h3><h4 id="1-基础版（左闭右闭）"><a href="#1-基础版（左闭右闭）" class="headerlink" title="1. 基础版（左闭右闭）"></a>1. 基础版（左闭右闭）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Params：a - 待查找的升序数组</span><br><span class="hljs-comment">//        target - 待查找的目标值</span><br><span class="hljs-comment">// Returns：找到则返回值索引</span><br><span class="hljs-comment">//		    找不到返回 -1</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = a.length - <span class="hljs-number">1</span>;   <span class="hljs-comment">//设置前后的指针</span><br>    <span class="hljs-keyword">while</span> (i &lt;= j) &#123;           <span class="hljs-comment">// i-j范围内有东西</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> (i + j) &gt;&gt;&gt; <span class="hljs-number">1</span>;     <span class="hljs-comment">// 无符号右移，相当于除2后取整</span><br>        <span class="hljs-keyword">if</span> (target &lt; a[m]) &#123;			<span class="hljs-comment">// 目标值在左边</span><br>            j = m - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[m] &lt; target) &#123;		<span class="hljs-comment">// 目标值在右边</span><br>            i = m + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;                   <span class="hljs-comment">// 找到了</span><br>            <span class="hljs-keyword">return</span> m;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="2-进阶版（左闭右开）"><a href="#2-进阶版（左闭右开）" class="headerlink" title="2. 进阶版（左闭右开）"></a>2. 进阶版（左闭右开）</h4><p>左边指针只作为一个边界，不参与运算</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = a.length;   <br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;           <br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> (i + j) &gt;&gt;&gt; <span class="hljs-number">1</span>;     <br>        <span class="hljs-keyword">if</span> (target &lt; a[m]) &#123;			<br>            j = m ;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[m] &lt; target) &#123;		<br>            i = m + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;                   <br>            <span class="hljs-keyword">return</span> m;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="3-复杂度"><a href="#3-复杂度" class="headerlink" title="3. 复杂度"></a>3. 复杂度</h3><p>时间复杂度：用来衡量一个算法的执行，随数据规模增大，而增长的时间成本</p>
<ul>
<li><p>最坏情况：<code>O(log n)</code></p>
</li>
<li><p>最好情况：如果待查找元素恰好在数组中央，只需要循环一次 <code>O(1)</code></p>
</li>
</ul>
<p>空间复杂度：用来衡量一个算法执行随数据规模增大，而增长的<strong>额外</strong>空间成本</p>
<ul>
<li>需要常数个指针 <code>i,j,m</code>，因此额外占用的空间是 <code>O(1)</code></li>
</ul>
<h3 id="4-tips"><a href="#4-tips" class="headerlink" title="4. tips"></a>4. tips</h3><ol>
<li>无符号右移：<code>int m = (i + j) &gt;&gt;&gt; 1;</code>，底层原理是将十进制数字转为2进制数字，并将二进制数向右移动1位</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">偶数无符号右移</span> <span class="hljs-string">-&gt;</span> <span class="hljs-string">除2</span><br><span class="hljs-number">16</span>         <span class="hljs-bullet">-</span> <span class="hljs-number">0000 </span><span class="hljs-number">1000</span> <span class="hljs-bullet">-</span> <span class="hljs-number">16</span><br><span class="hljs-string">(16)</span> <span class="hljs-string">&gt;&gt;&gt;</span> <span class="hljs-number">1</span> <span class="hljs-bullet">-</span> <span class="hljs-number">0000 </span><span class="hljs-number">0100</span> <span class="hljs-bullet">-</span> <span class="hljs-number">8</span><br><br><span class="hljs-string">基数数无符号右移</span> <span class="hljs-string">-&gt;</span> <span class="hljs-string">除2-1</span><br><span class="hljs-number">9</span>         <span class="hljs-bullet">-</span> <span class="hljs-number">0000 </span><span class="hljs-number">0101</span> <span class="hljs-bullet">-</span> <span class="hljs-number">9</span><br><span class="hljs-string">(9)</span> <span class="hljs-string">&gt;&gt;&gt;</span> <span class="hljs-number">1</span> <span class="hljs-bullet">-</span> <span class="hljs-number">0000 </span><span class="hljs-number">0010</span> <span class="hljs-bullet">-</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>



<ol start="2">
<li>用<code>int m = (i + j) &gt;&gt;&gt; 1;</code>，而不用<code>int m = (i + j) / 2;</code>的原因，后者数字过大容易超出int限制出现负值</li>
</ol>
<h1 id="二、数据结构-1"><a href="#二、数据结构-1" class="headerlink" title="二、数据结构"></a>二、数据结构</h1><h2 id="1-数组-1"><a href="#1-数组-1" class="headerlink" title="1. 数组"></a>1. 数组</h2>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%BC%80%E5%8F%91/" class="category-chain-item">开发</a>
  
  
    <span>></span>
    
  <a href="/categories/%E5%BC%80%E5%8F%91/%E7%AE%97%E6%B3%95/" class="category-chain-item">算法</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%BC%80%E5%8F%91/" class="print-no-link">#开发</a>
      
        <a href="/tags/%E7%AE%97%E6%B3%95/" class="print-no-link">#算法</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>算法入门至精通</div>
      <div>http://example.com/2023/11/30/算法入门至精通/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>张辰</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年11月30日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/11/30/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/" title="Matplotlib+Numpy+Pandas数据分析">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Matplotlib+Numpy+Pandas数据分析</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/11/30/%E4%BA%92%E8%81%94%E7%BD%91%E9%BB%91%E8%AF%9D/" title="互联网黑话">
                        <span class="hidden-mobile">互联网黑话</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  



  <script>
  Fluid.utils.createScript('https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js', function() {
    mermaid.initialize({"theme":"default"});

    Fluid.utils.listenDOMLoaded(function() {
      Fluid.events.registerRefreshCallback(function() {
        if ('mermaid' in window) {
          mermaid.init();
        }
      });
    });
  });
</script>






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量
        <span id="busuanzi_value_site_pv"></span>
        次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数
        <span id="busuanzi_value_site_uv"></span>
        人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
