

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="张辰">
  <meta name="keywords" content="">
  
    <meta name="description" content="从零开始学算法">
<meta property="og:type" content="article">
<meta property="og:title" content="算法入门至精通">
<meta property="og:url" content="http://example.com/2023/11/30/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E8%87%B3%E7%B2%BE%E9%80%9A/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="从零开始学算法">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/algorithm_pic/1.jpg">
<meta property="article:published_time" content="2023-11-30T12:00:00.000Z">
<meta property="article:modified_time" content="2025-05-05T16:07:38.351Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="开发">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/algorithm_pic/1.jpg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>算法入门至精通 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.6","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/banner_hexo.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="算法入门至精通"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-11-30 20:00" pubdate>
          2023年11月30日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          12k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          97 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">算法入门至精通</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="一、复杂度分析"><a href="#一、复杂度分析" class="headerlink" title="一、复杂度分析"></a>一、复杂度分析</h1><p>学习链接：<a target="_blank" rel="noopener" href="https://www.hello-algo.com/">https://www.hello-algo.com/</a></p>
<h2 id="1-时间复杂度"><a href="#1-时间复杂度" class="headerlink" title="1. 时间复杂度"></a>1. 时间复杂度</h2><p>运行时间可以直观且准确地反映算法的效率。如果我们想准确预估一段代码的运行时间，应该如何操作呢？</p>
<ol>
<li><strong>确定运行平台</strong>，包括硬件配置、编程语言、系统环境等，这些因素都会影响代码的运行效率。</li>
<li><strong>评估各种计算操作所需的运行时间</strong>，例如加法操作 <code>+</code> 需要 1 ns ，乘法操作 <code>*</code> 需要 10 ns ，打印操作 <code>print()</code> 需要 5 ns 等。</li>
<li><strong>统计代码中所有的计算操作</strong>，并将所有操作的执行时间求和，从而得到运行时间。</li>
</ol>
<p>例如在以下代码中，输入数据大小为 n ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在某运行平台下</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">algorithm</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;  <span class="hljs-comment">// 1 ns</span><br>    a = a + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 1 ns</span><br>    a = a * <span class="hljs-number">2</span>;  <span class="hljs-comment">// 10 ns</span><br>    <span class="hljs-comment">// 循环 n 次</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;  <span class="hljs-comment">// 1 ns ，每轮都要执行 i++</span><br>        System.out.println(<span class="hljs-number">0</span>);     <span class="hljs-comment">// 5 ns</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>根据以上方法，可以得到算法的运行时间为 (6n+12) ns ：</p>
<center>1+1+10+(1+5)×n=6n+12</center>

<p>但实际上，<strong>统计算法的运行时间既不合理也不现实</strong>。首先，我们不希望将预估时间和运行平台绑定，因为算法需要在各种不同的平台上运行。其次，我们很难获知每种操作的运行时间，这给预估过程带来了极大的难度。</p>
<h3 id="1-统计时间增长趋势"><a href="#1-统计时间增长趋势" class="headerlink" title="1. 统计时间增长趋势"></a>1. 统计时间增长趋势</h3><p>时间复杂度分析统计的不是算法运行时间，<strong>而是算法运行时间随着数据量变大时的增长趋势</strong>。</p>
<p>“时间增长趋势”这个概念比较抽象，我们通过一个例子来加以理解。假设输入数据大小为 n ，给定三个算法 <code>A</code>、<code>B</code> 和 <code>C</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 算法 A 的时间复杂度：常数阶</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">algorithm_A</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    System.out.println(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-comment">// 算法 B 的时间复杂度：线性阶</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">algorithm_B</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        System.out.println(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 算法 C 的时间复杂度：常数阶</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">algorithm_C</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++) &#123;<br>        System.out.println(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>下图展示了以上三个算法函数的时间复杂度。</p>
<ul>
<li>算法 <code>A</code> 只有 1 个打印操作，算法运行时间不随着 n 增大而增长。我们称此算法的时间复杂度为“常数阶”。</li>
<li>算法 <code>B</code> 中的打印操作需要循环 n 次，算法运行时间随着 n 增大呈线性增长。此算法的时间复杂度被称为“线性阶”。</li>
<li>算法 <code>C</code> 中的打印操作需要循环 1000000 次，虽然运行时间很长，但它与输入数据大小 n 无关。因此 <code>C</code> 的时间复杂度和 <code>A</code> 相同，仍为“常数阶”。</li>
</ul>
<div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/9.png" srcset="/img/loading.gif" lazyload alt="图片描述">
</div>

<p>相较于直接统计算法的运行时间，时间复杂度分析有哪些特点呢？</p>
<ul>
<li><strong>时间复杂度能够有效评估算法效率</strong>。例如，算法 <code>B</code> 的运行时间呈线性增长，在 n&gt;1 时比算法 <code>A</code> 更慢，在 n&gt;1000000 时比算法 <code>C</code> 更慢。事实上，只要输入数据大小 n 足够大，复杂度为“常数阶”的算法一定优于“线性阶”的算法，这正是时间增长趋势的含义。</li>
<li><strong>时间复杂度的推算方法更简便</strong>。显然，运行平台和计算操作类型都与算法运行时间的增长趋势无关。因此在时间复杂度分析中，我们可以简单地将所有计算操作的执行时间视为相同的“单位时间”，从而将“计算操作运行时间统计”简化为“计算操作数量统计”，这样一来估算难度就大大降低了。</li>
<li><strong>时间复杂度也存在一定的局限性</strong>。例如，尽管算法 <code>A</code> 和 <code>C</code> 的时间复杂度相同，但实际运行时间差别很大。同样，尽管算法 <code>B</code> 的时间复杂度比 <code>C</code> 高，但在输入数据大小 n 较小时，算法 <code>B</code> 明显优于算法 <code>C</code> 。在这些情况下，我们很难仅凭时间复杂度判断算法效率的高低。当然，尽管存在上述问题，复杂度分析仍然是评判算法效率最有效且常用的方法。</li>
</ul>
<h3 id="2-函数渐近上界"><a href="#2-函数渐近上界" class="headerlink" title="2. 函数渐近上界"></a>2. 函数渐近上界</h3><p>给定一个输入大小为 n 的函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">algorithm</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">// +1</span><br>    a = a + <span class="hljs-number">1</span>;  <span class="hljs-comment">// +1</span><br>    a = a * <span class="hljs-number">2</span>;  <span class="hljs-comment">// +1</span><br>    <span class="hljs-comment">// 循环 n 次</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123; <span class="hljs-comment">// +1（每轮都执行 i ++）</span><br>        System.out.println(<span class="hljs-number">0</span>);    <span class="hljs-comment">// +1</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>设算法的操作数量是一个关于输入数据大小 n 的函数，记为 T(n) ，则以上函数的操作数量为：</p>
<center>T(n)=3+2n</center>

<p>T(n) 是一次函数，说明其运行时间的增长趋势是线性的，因此它的时间复杂度是线性阶。</p>
<p>我们将线性阶的时间复杂度记为 O(n) ，这个数学符号称为「大 O 记号 big-O notation」，表示函数 T(n) 的「渐近上界 asymptotic upper bound」。</p>
<p>时间复杂度分析本质上是计算“操作数量 T(n)”的渐近上界，它具有明确的数学定义。</p>
<ul>
<li><strong>函数渐近上界</strong></li>
</ul>
<p>若存在正实数 c 和实数 n<sub>0 </sub>，使得对于所有的 n&gt;n<sub>0</sub> ，均有 T(n)≤c⋅f(n) ，则可认为 f(n) 给出了 T(n) 的一个渐近上界，记为 T(n)&#x3D;O(f(n)) 。</p>
<p>如下图所示，计算渐近上界就是寻找一个函数 f(n) ，使得当 n 趋向于无穷大时，T(n) 和 f(n) 处于相同的增长级别，仅相差一个常数项 c 的倍数。</p>
<div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/10.png" srcset="/img/loading.gif" lazyload alt="图片描述">
</div>



<h3 id="3-推算方法"><a href="#3-推算方法" class="headerlink" title="3. 推算方法"></a>3. 推算方法</h3><ol>
<li><p><strong>时间复杂度由 T(n) 中最高阶的项来决定</strong>。这是因为在 n 趋于无穷大时，最高阶的项将发挥主导作用，其他项的影响都可以忽略。</p>
<p>例：</p>
<table>
<thead>
<tr>
<th>操作数量T(n)</th>
<th>时间复杂符O(f(n))</th>
</tr>
</thead>
<tbody><tr>
<td>100000</td>
<td>O(1)</td>
</tr>
<tr>
<td>3n + 2</td>
<td>O(n)</td>
</tr>
<tr>
<td>2n<sup>2</sup> + 3n + 2</td>
<td>O(n<sup>2</sup>)</td>
</tr>
<tr>
<td>n<sup>3</sup>+10000n<sup>2</sup></td>
<td>O(n<sup>3</sup>)</td>
</tr>
<tr>
<td>2<sup>n</sup> + 10000n<sup>10000</sup></td>
<td>O(2<sup>n</sup>)</td>
</tr>
</tbody></table>
</li>
<li><p>常见类型</p>
<p>O(1) &lt; O(log<sub>n</sub>) &lt; O(n) &lt; O(nlog<sub>n</sub>) &lt; O(n<sup>2</sup>) &lt;  O(2<sup>n</sup>) &lt; O(n!)</p>
<div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/3.png" srcset="/img/loading.gif" lazyload alt="图片描述">
</div></li>
</ol>
<h3 id="4-常见类型"><a href="#4-常见类型" class="headerlink" title="4. 常见类型"></a>4. 常见类型</h3><h4 id="1-常数阶O-1"><a href="#1-常数阶O-1" class="headerlink" title="1. 常数阶O(1)"></a>1. 常数阶O(1)</h4><p>常数阶的操作数量与输入数据大小n无关，即不随着n的变化而变化。</p>
<p>在以下函数中，尽管操作数量 <code>size</code> 可能很大，但由于其与输入数据大小n无关，因此时间复杂度仍为O(1) ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 常数阶 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">constant</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">100000</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++)<br>        count++;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="2-线性阶O-n"><a href="#2-线性阶O-n" class="headerlink" title="2. 线性阶O(n)"></a>2. 线性阶O(n)</h4><p>线性阶的操作数量相对于输入数据大小n以线性级别增长。线性阶通常出现在单层循环中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 线性阶 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">linear</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)<br>        count++;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>遍历数组和遍历链表等操作的时间复杂度均为O(n) ，其中n为数组或链表的长度：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 线性阶（遍历数组） */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">arrayTraversal</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 循环次数与数组长度成正比</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        count++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>值得注意的是，<strong>输入数据大小n需根据输入数据的类型来具体确定</strong>。比如在第一个示例中，变量n为输入数据大小；在第二个示例中，数组长度n为数据大小。</p>
<h4 id="3-平方阶O-n2"><a href="#3-平方阶O-n2" class="headerlink" title="3. 平方阶O(n2)"></a>3. 平方阶O(n<sup>2</sup>)</h4><p>平方阶的操作数量相对于输入数据大小n以平方级别增长。平方阶通常出现在嵌套循环中，外层循环和内层循环的时间复杂度都为O(n) ，因此总体的时间复杂度为O(n<sup>2</sup>) ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 平方阶 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">quadratic</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 循环次数与数组长度成平方关系</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            count++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>下图对比了常数阶、线性阶和平方阶三种时间复杂度。</p>
<div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/4.png" srcset="/img/loading.gif" lazyload alt="图片描述">
</div>



<p>以冒泡排序为例，外层循环执行 n−1 次，内层循环执行 n−1、n−2、…、2、1 次，平均为 n&#x2F;2 次，因此时间复杂度为 O((n−1)n&#x2F;2)&#x3D;O(n<sup>2</sup>) ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 平方阶（冒泡排序） */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">bubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 计数器</span><br>    <span class="hljs-comment">// 外循环：未排序区间为 [0, i]</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">// 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[j] &gt; nums[j + <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-comment">// 交换 nums[j] 与 nums[j + 1]</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> nums[j];<br>                nums[j] = nums[j + <span class="hljs-number">1</span>];<br>                nums[j + <span class="hljs-number">1</span>] = tmp;<br>                count += <span class="hljs-number">3</span>; <span class="hljs-comment">// 元素交换包含 3 个单元操作</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="5-指数阶O-2n"><a href="#5-指数阶O-2n" class="headerlink" title="5. 指数阶O(2n)"></a>5. 指数阶O(2<sup>n</sup>)</h4><p>生物学的“细胞分裂”是指数阶增长的典型例子：初始状态为 1 个细胞，分裂一轮后变为 2 个，分裂两轮后变为 4 个，以此类推，分裂 n 轮后有 2<sup>n</sup> 个细胞。</p>
<p>下和以下代码模拟了细胞分裂的过程，时间复杂度为 ）O(2<sup>n</sup>) ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 指数阶（循环实现） */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">exponential</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, base = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 细胞每轮一分为二，形成数列 1, 2, 4, 8, ..., 2^(n-1)</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; base; j++) &#123;<br>            count++;<br>        &#125;<br>        base *= <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-comment">// count = 1 + 2 + 4 + 8 + .. + 2^(n-1) = 2^n - 1</span><br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure>

<div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/5.png" srcset="/img/loading.gif" lazyload alt="图片描述">
</div>



<p>在实际算法中，指数阶常出现于递归函数中。例如在以下代码中，其递归地一分为二，经过n次分裂后停止：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 指数阶（递归实现） */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">expRecur</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> expRecur(n - <span class="hljs-number">1</span>) + expRecur(n - <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>指数阶增长非常迅速，在穷举法（暴力搜索、回溯等）中比较常见。对于数据规模较大的问题，指数阶是不可接受的，通常需要使用动态规划或贪心算法等来解决。</p>
<h4 id="6-对数阶O-logn"><a href="#6-对数阶O-logn" class="headerlink" title="6. 对数阶O(logn)"></a>6. 对数阶O(log<sub>n</sub>)</h4><p>与指数阶相反，对数阶反映了“每轮缩减到一半”的情况。设输入数据大小为n，由于每轮缩减到一半，因此循环次数是 log<sub>2</sub><sup>n</sup>，即 2<sup>n</sup> 的反函数。</p>
<p>下图和以下代码模拟了“每轮缩减到一半”的过程，时间复杂度为 O(log<sub>2</sub><sup>n</sup>) ，简记为 O(log⁡<sup>n</sup>) ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 对数阶（循环实现） */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">logarithmic</span><span class="hljs-params">(<span class="hljs-type">float</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">1</span>) &#123;<br>        n = n / <span class="hljs-number">2</span>;<br>        count++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure>

<div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/6.png" srcset="/img/loading.gif" lazyload alt="图片描述">
</div>

<p>与指数阶类似，对数阶也常出现于递归函数中。以下代码形成了一棵高度为 log<sub>2</sub><sup>⁡n</sup> 的递归树：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 对数阶（递归实现） */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">logRecur</span><span class="hljs-params">(<span class="hljs-type">float</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> logRecur(n / <span class="hljs-number">2</span>) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对数阶常出现于基于分治策略的算法中，体现了“一分为多”和“化繁为简”的算法思想。它增长缓慢，是仅次于常数阶的理想的时间复杂度。</p>
<h4 id="7-线性对数阶-O-nlog⁡n"><a href="#7-线性对数阶-O-nlog⁡n" class="headerlink" title="7. 线性对数阶 O(nlog⁡n)"></a>7. 线性对数阶 O(nlog⁡<sup>n</sup>)</h4><p>线性对数阶常出现于嵌套循环中，两层循环的时间复杂度分别为 O(log⁡<sup>n</sup>) 和 O(n) 。相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 线性对数阶 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">linearLogRecur</span><span class="hljs-params">(<span class="hljs-type">float</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> linearLogRecur(n / <span class="hljs-number">2</span>) + linearLogRecur(n / <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        count++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>下图展示了线性对数阶的生成方式。二叉树的每一层的操作总数都为n，树共有 log<sub>2</sub><sup>n</sup>+1 层，因此时间复杂度为 O(nlog⁡<sup>n</sup>) 。</p>
<div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/7.png" srcset="/img/loading.gif" lazyload alt="图片描述">
</div>

<p>主流排序算法的时间复杂度通常为 O(nlog⁡<sup>n</sup>) ，例如快速排序、归并排序、堆排序等。</p>
<h4 id="8-阶乘阶-O-n"><a href="#8-阶乘阶-O-n" class="headerlink" title="8.  阶乘阶 O(n!)"></a>8.  阶乘阶 O(n!)</h4><p>阶乘阶对应数学上的“全排列”问题。给定 n 个互不重复的元素，求其所有可能的排列方案，方案数量为：</p>
<center>n!=n×(n−1)×(n−2)×⋯×2×1</center>

<p>阶乘通常使用递归实现。如下图 和以下代码所示，第一层分裂出 n 个，第二层分裂出 n−1 个，以此类推，直至第 n 层时停止分裂：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 阶乘阶（递归实现） */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">factorialRecur</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 从 1 个分裂出 n 个</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        count += factorialRecur(n - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure>



<div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/8.png" srcset="/img/loading.gif" lazyload alt="图片描述">
</div>

<ul>
<li>请注意，因为当 n≥4 时恒有 n! &gt; 2<sup>n</sup> ，所以阶乘阶比指数阶增长得更快，在 n 较大时也是不可接受的。</li>
</ul>
<h3 id="5-最差、最佳、平均时间复杂度"><a href="#5-最差、最佳、平均时间复杂度" class="headerlink" title="5. 最差、最佳、平均时间复杂度"></a>5. 最差、最佳、平均时间复杂度</h3><p><strong>算法的时间效率往往不是固定的，而是与输入数据的分布有关</strong>。假设输入一个长度为 n 的数组 <code>nums</code> ，其中 <code>nums</code> 由从 1 至 n 的数字组成，每个数字只出现一次；但元素顺序是随机打乱的，任务目标是返回元素 1 的索引。我们可以得出以下结论。</p>
<ul>
<li>当 <code>nums = [?, ?, ..., 1]</code> ，即当末尾元素是 1 时，需要完整遍历数组，<strong>达到最差时间复杂度 O(n)</strong> 。</li>
<li>当 <code>nums = [1, ?, ?, ...]</code> ，即当首个元素为 1 时，无论数组多长都不需要继续遍历，<strong>达到最佳时间复杂度 Ω(1)</strong> 。</li>
</ul>
<p>“最差时间复杂度”对应函数渐近上界，使用大 O 记号表示。相应地，“最佳时间复杂度”对应函数渐近下界，用 Ω 记号表示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 生成一个数组，元素为 &#123; 1, 2, ..., n &#125;，顺序被打乱 */</span><br><span class="hljs-type">int</span>[] randomNumbers(<span class="hljs-type">int</span> n) &#123;<br>    Integer[] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[n];<br>    <span class="hljs-comment">// 生成数组 nums = &#123; 1, 2, 3, ..., n &#125;</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        nums[i] = i + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 随机打乱数组元素</span><br>    Collections.shuffle(Arrays.asList(nums));<br>    <span class="hljs-comment">// Integer[] -&gt; int[]</span><br>    <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        res[i] = nums[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">/* 查找数组 nums 中数字 1 所在索引 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">findOne</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-comment">// 当元素 1 在数组头部时，达到最佳时间复杂度 O(1)</span><br>        <span class="hljs-comment">// 当元素 1 在数组尾部时，达到最差时间复杂度 O(n)</span><br>        <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>值得说明的是，我们在实际中很少使用最佳时间复杂度，因为通常只有在很小概率下才能达到，可能会带来一定的误导性。<strong>而最差时间复杂度更为实用，因为它给出了一个效率安全值</strong>，让我们可以放心地使用算法。</p>
<p>从上述示例可以看出，最差时间复杂度和最佳时间复杂度只出现于“特殊的数据分布”，这些情况的出现概率可能很小，并不能真实地反映算法运行效率。相比之下，<strong>平均时间复杂度可以体现算法在随机输入数据下的运行效率</strong>，用 Θ 记号来表示。</p>
<p>对于部分算法，我们可以简单地推算出随机数据分布下的平均情况。比如上述示例，由于输入数组是被打乱的，因此元素 1 出现在任意索引的概率都是相等的，那么算法的平均循环次数就是数组长度的一半 n&#x2F;2 ，平均时间复杂度为 Θ(n&#x2F;2)&#x3D;Θ(n) 。</p>
<p>但对于较为复杂的算法，计算平均时间复杂度往往比较困难，因为很难分析出在数据分布下的整体数学期望。在这种情况下，我们通常使用最差时间复杂度作为算法效率的评判标准。</p>
<ul>
<li>为什么很少看到 Θ 符号？</li>
</ul>
<p>可能由于 O 符号过于朗朗上口，因此我们常常使用它来表示平均时间复杂度。但从严格意义上讲，这种做法并不规范。在本书和其他资料中，若遇到类似“平均时间复杂度 O(n)”的表述，请将其直接理解为 Θ(n) 。</p>
<h2 id="2-空间复杂度"><a href="#2-空间复杂度" class="headerlink" title="2.  空间复杂度"></a>2.  空间复杂度</h2><p>「空间复杂度 space complexity」用于衡量算法占用内存空间随着数据量变大时的增长趋势。这个概念与时间复杂度非常类似，只需将“运行时间”替换为“占用内存空间”。</p>
<h3 id="1-算法相关空间"><a href="#1-算法相关空间" class="headerlink" title="1.  算法相关空间"></a>1.  算法相关空间</h3><p>算法在运行过程中使用的内存空间主要包括以下几种。</p>
<ul>
<li><strong>输入空间</strong>：用于存储算法的输入数据。</li>
<li><strong>暂存空间</strong>：用于存储算法在运行过程中的变量、对象、函数上下文等数据。</li>
<li><strong>输出空间</strong>：用于存储算法的输出数据。</li>
</ul>
<p>一般情况下，空间复杂度的统计范围是“暂存空间”加上“输出空间”。</p>
<p>暂存空间可以进一步划分为三个部分。</p>
<ul>
<li><strong>暂存数据</strong>：用于保存算法运行过程中的各种常量、变量、对象等。</li>
<li><strong>栈帧空间</strong>：用于保存调用函数的上下文数据。系统在每次调用函数时都会在栈顶部创建一个栈帧，函数返回后，栈帧空间会被释放。</li>
<li><strong>指令空间</strong>：用于保存编译后的程序指令，在实际统计中通常忽略不计。</li>
</ul>
<p>在分析一段程序的空间复杂度时，<strong>我们通常统计暂存数据、栈帧空间和输出数据三部分</strong>，如下图所示。</p>
<div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/11.png" srcset="/img/loading.gif" lazyload alt="图片描述">
</div>

<p>相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 类 */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    Node next;<br>    Node(<span class="hljs-type">int</span> x) &#123; val = x; &#125;<br>&#125;<br><br><span class="hljs-comment">/* 函数 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">function</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 执行某些操作...</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">algorithm</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;        <span class="hljs-comment">// 输入数据</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;          <span class="hljs-comment">// 暂存数据（常量）</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;                <span class="hljs-comment">// 暂存数据（变量）</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 暂存数据（对象）</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> function();       <span class="hljs-comment">// 栈帧空间（调用函数）</span><br>    <span class="hljs-keyword">return</span> a + b + c;         <span class="hljs-comment">// 输出数据</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="2-推算方法"><a href="#2-推算方法" class="headerlink" title="2.  推算方法"></a>2.  推算方法</h3><p>空间复杂度的推算方法与时间复杂度大致相同，只需将统计对象从“操作数量”转为“使用空间大小”。</p>
<p>而与时间复杂度不同的是，<strong>我们通常只关注最差空间复杂度</strong>。这是因为内存空间是一项硬性要求，我们必须确保在所有输入数据下都有足够的内存空间预留。</p>
<p>观察以下代码，最差空间复杂度中的“最差”有两层含义。</p>
<ol>
<li><strong>以最差输入数据为准</strong>：当 n&lt;10 时，空间复杂度为 O(1) ；但当 n&gt;10 时，初始化的数组 <code>nums</code> 占用 O(n) 空间，因此最差空间复杂度为 O(n) </li>
<li><strong>以算法运行中的峰值内存为准</strong>：例如，程序在执行最后一行之前，占用 O(1) 空间；当初始化数组 <code>nums</code> 时，程序占用 O(n) 空间，因此最差空间复杂度为 O(n) 。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">algorithm</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;                   <span class="hljs-comment">// O(1)</span><br>    <span class="hljs-type">int</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10000</span>];    <span class="hljs-comment">// O(1)</span><br>    <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">10</span>)<br>        <span class="hljs-type">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n]; <span class="hljs-comment">// O(n)</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>在递归函数中，需要注意统计栈帧空间</strong>。观察以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">function</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 执行某些操作</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/* 循环 O(1) */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">loop</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        function();<br>    &#125;<br>&#125;<br><span class="hljs-comment">/* 递归 O(n) */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">recur</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">return</span> recur(n - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>函数 <code>loop()</code> 和 <code>recur()</code> 的时间复杂度都为 O(n) ，但空间复杂度不同。</p>
<ul>
<li>函数 <code>loop()</code> 在循环中调用了 n 次 <code>function()</code> ，每轮中的 <code>function()</code> 都返回并释放了栈帧空间，因此空间复杂度仍为 O(1) 。</li>
<li>递归函数 <code>recur()</code> 在运行过程中会同时存在 n 个未返回的 <code>recur()</code> ，从而占用 O(n) 的栈帧空间。</li>
</ul>
<h3 id="3-常见类型"><a href="#3-常见类型" class="headerlink" title="3. 常见类型"></a>3. 常见类型</h3><p>设输入数据大小为 n ，下图展示了常见的空间复杂度类型（从低到高排列）。</p>
<center>O(1) < O(log<sub>n</sub>) < O(n) < O(n<sub>2</sub>) < O(2<sup>n</sup>)</center>

<center>常数阶 < 对数阶 < 线性阶 < 平方阶 < 指数阶</center>

<div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/12.png" srcset="/img/loading.gif" lazyload alt="图片描述">
</div>


<h4 id="1-常数阶-O-1"><a href="#1-常数阶-O-1" class="headerlink" title="1.常数阶 O(1)"></a>1.常数阶 O(1)</h4><p>常数阶常见于数量与输入数据大小 n 无关的常量、变量、对象。</p>
<p>需要注意的是，在循环中初始化变量或调用函数而占用的内存，在进入下一循环后就会被释放，因此不会累积占用空间，空间复杂度仍为 O(1) ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 函数 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">function</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 执行某些操作</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 常数阶 */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">constant</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-comment">// 常量、变量、对象占用 O(1) 空间</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10000</span>];<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 循环中的变量占用 O(1) 空间</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// 循环中的函数占用 O(1) 空间</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        function();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="2-线性阶-O-n"><a href="#2-线性阶-O-n" class="headerlink" title="2.线性阶 O(n)"></a>2.线性阶 O(n)</h4><p>线性阶常见于元素数量与 n 成正比的数组、链表、栈、队列等：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 线性阶 */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">linear</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-comment">// 长度为 n 的数组占用 O(n) 空间</span><br>    <span class="hljs-type">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    <span class="hljs-comment">// 长度为 n 的列表占用 O(n) 空间</span><br>    List&lt;ListNode&gt; nodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        nodes.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(i));<br>    &#125;<br>    <span class="hljs-comment">// 长度为 n 的哈希表占用 O(n) 空间</span><br>    Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        map.put(i, String.valueOf(i));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如下图所示，此函数的递归深度为 n ，即同时存在 n 个未返回的 <code>linear_recur()</code> 函数，使用 O(n) 大小的栈帧空间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 线性阶（递归实现） */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">linearRecur</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;递归 n = &quot;</span> + n);<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span>;<br>    linearRecur(n - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/13.png" srcset="/img/loading.gif" lazyload alt="图片描述">
</div>



<h4 id="3-平方阶-O-n2"><a href="#3-平方阶-O-n2" class="headerlink" title="3. 平方阶 O(n2)"></a>3. 平方阶 O(n<sup>2</sup>)</h4><p>平方阶常见于矩阵和图，元素数量与 n 成平方关系：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 平方阶 */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">quadratic</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-comment">// 矩阵占用 O(n^2) 空间</span><br>    <span class="hljs-type">int</span>[][] numMatrix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>    <span class="hljs-comment">// 二维列表占用 O(n^2) 空间</span><br>    List&lt;List&lt;Integer&gt;&gt; numList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            tmp.add(<span class="hljs-number">0</span>);<br>        &#125;<br>        numList.add(tmp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如下图所示，该函数的递归深度为 n ，在每个递归函数中都初始化了一个数组，长度分别为 n、n−1、…、2、1 ，平均长度为 n&#x2F;2 ，因此总体占用 O(n<sup>2</sup>) 空间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 平方阶（递归实现） */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">quadraticRecur</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 数组 nums 长度为 n, n-1, ..., 2, 1</span><br>    <span class="hljs-type">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    System.out.println(<span class="hljs-string">&quot;递归 n = &quot;</span> + n + <span class="hljs-string">&quot; 中的 nums 长度 = &quot;</span> + nums.length);<br>    <span class="hljs-keyword">return</span> quadraticRecur(n - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>



<div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/14.png" srcset="/img/loading.gif" lazyload alt="图片描述">
</div>



<h4 id="4-指数阶-O-2n"><a href="#4-指数阶-O-2n" class="headerlink" title="4.指数阶 O(2n)"></a>4.指数阶 O(2<sup>n</sup>)</h4><p>指数阶常见于二叉树。观察下图 ，层数为 n 的“满二叉树”的节点数量为 2<sup>n</sup>−1 ，占用 O(2<sup>n</sup>) 空间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 指数阶（建立满二叉树） */</span><br>TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">0</span>);<br>    root.left = buildTree(n - <span class="hljs-number">1</span>);<br>    root.right = buildTree(n - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure>

<div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/15.png" srcset="/img/loading.gif" lazyload alt="图片描述">
</div>



<h4 id="5-对数阶-O-logn⁡"><a href="#5-对数阶-O-logn⁡" class="headerlink" title="5. 对数阶 O(logn⁡)"></a>5. 对数阶 O(log<sub>n</sub>⁡)</h4><p>对数阶常见于分治算法。例如归并排序，输入长度为 n 的数组，每轮递归将数组从中点处划分为两半，形成高度为 log⁡<sub>n</sub> 的递归树，使用 O(log⁡<sub>n</sub>) 栈帧空间。</p>
<p>再例如将数字转化为字符串，输入一个正整数 n ，它的位数为 ⌊log<sub>10</sub><sup>⁡n</sup>⌋+1 ，即对应字符串长度为 ⌊log<sub>10</sub><sup>⁡n</sup>⌋+1 ，因此空间复杂度为 O(log<sub>10</sub><sup>⁡n</sup>+1)&#x3D;O(log⁡<sub>n</sub>) 。</p>
<h4 id="6-权衡时间与空间"><a href="#6-权衡时间与空间" class="headerlink" title="6. 权衡时间与空间"></a>6. 权衡时间与空间</h4><p>理想情况下，我们希望算法的时间复杂度和空间复杂度都能达到最优。然而在实际情况中，同时优化时间复杂度和空间复杂度通常非常困难。</p>
<p><strong>降低时间复杂度通常需要以提升空间复杂度为代价，反之亦然</strong>。我们将牺牲内存空间来提升算法运行速度的思路称为“以空间换时间”；反之，则称为“以时间换空间”。</p>
<p>选择哪种思路取决于我们更看重哪个方面。在大多数情况下，<mark>时间比空间更宝贵</mark>，因此“以空间换时间”通常是更常用的策略。当然，在数据量很大的情况下，控制空间复杂度也非常重要。</p>
<h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><h3 id="1-重点回顾"><a href="#1-重点回顾" class="headerlink" title="1.  重点回顾"></a>1.  重点回顾</h3><p><strong>算法效率评估</strong></p>
<ul>
<li>时间效率和空间效率是衡量算法优劣的两个主要评价指标</li>
</ul>
<p><strong>时间复杂度</strong></p>
<ul>
<li>时间复杂度用于衡量算法运行时间随数据量增长的趋势，可以有效评估算法效率，但在某些情况下可能失效，如在输入的数据量较小或时间复杂度相同时，无法精确对比算法效率的优劣。</li>
<li>最差时间复杂度使用大 O 符号表示，对应函数渐近上界，反映当 n 趋向正无穷时，操作数量 T(n) 的增长级别。</li>
<li>推算时间复杂度分为两步，首先统计操作数量，然后判断渐近上界。</li>
<li>常见时间复杂度从低到高排列有 O(1)、O(log⁡<sub>n</sub>)、O(n)、O(nlog⁡<sub>n</sub>)、O(n<sup>2</sup>)、O(2<sup>n</sup>) 和 O(n!) 等。</li>
<li>某些算法的时间复杂度非固定，而是与输入数据的分布有关。时间复杂度分为最差、最佳、平均时间复杂度，最佳时间复杂度几乎不用，因为输入数据一般需要满足严格条件才能达到最佳情况。</li>
<li>平均时间复杂度反映算法在随机数据输入下的运行效率，最接近实际应用中的算法性能。计算平均时间复杂度需要统计输入数据分布以及综合后的数学期望。</li>
</ul>
<p><strong>空间复杂度</strong></p>
<ul>
<li>用于衡量算法占用内存空间随数据量增长的趋势。</li>
<li>算法运行过程中的相关内存空间可分为输入空间、暂存空间、输出空间。通常情况下，输入空间不纳入空间复杂度计算。暂存空间可分为暂存数据、栈帧空间和指令空间，其中栈帧空间通常仅在递归函数中影响空间复杂度。</li>
<li>我们通常只关注最差空间复杂度，即统计算法在最差输入数据和最差运行时刻下的空间复杂度。</li>
<li>常见空间复杂度从低到高排列有 O(1)、O(log⁡<sub>n</sub>)、O(n)、O(n<sup>2</sup>) 和 O(2<sup>n</sup>) 等。</li>
</ul>
<h3 id="2-Q-A"><a href="#2-Q-A" class="headerlink" title="2.  Q &amp; A"></a>2.  Q &amp; A</h3><p><strong>Q</strong>：尾递归的空间复杂度是 O(1) 吗？</p>
<p>理论上，尾递归函数的空间复杂度可以优化至 O(1) 。不过绝大多数编程语言（例如 Java、Python、C++、Go、C# 等）不支持自动优化尾递归，因此通常认为空间复杂度是 O(n) 。</p>
<p><strong>Q</strong>：函数和方法这两个术语的区别是什么？</p>
<p>「函数 function」可以被独立执行，所有参数都以显式传递。「方法 method」与一个对象关联，被隐式传递给调用它的对象，能够对类的实例中包含的数据进行操作。</p>
<p>下面以几种常见的编程语言为例来说明。</p>
<ul>
<li>C 语言是过程式编程语言，没有面向对象的概念，所以只有函数。但可以通过创建结构体（struct）来模拟面向对象编程，与结构体相关联的函数就相当于其他编程语言中的方法</li>
<li>Java 和 C# 是面向对象的编程语言，代码块（方法）通常作为某个类的一部分。静态方法的行为类似于函数，因为它被绑定在类上，不能访问特定的实例变量</li>
<li>C++ 和 Python 既支持过程式编程（函数），也支持面向对象编程（方法）</li>
</ul>
<h1 id="二、线性与非线性"><a href="#二、线性与非线性" class="headerlink" title="二、线性与非线性"></a>二、线性与非线性</h1><p><strong>逻辑结构揭示了数据元素之间的逻辑关系</strong>。在数组和链表中，数据按照一定顺序排列，体现了数据之间的线性关系；而在树中，数据从顶部向下按层次排列，表现出“祖先”与“后代”之间的派生关系；图则由节点和边构成，反映了复杂的网络关系。</p>
<p>如下图所示，逻辑结构可分为“线性”和“非线性”两大类。线性结构比较直观，指数据在逻辑关系上呈线性排列；非线性结构则相反，呈非线性排列。</p>
<ul>
<li><strong>线性数据结构</strong>：数组、链表、栈、队列、哈希表，元素之间是一对一的顺序关系。</li>
<li><strong>非线性数据结构</strong>：树、堆、图、哈希表。</li>
</ul>
<p>非线性数据结构可以进一步划分为树形结构和网状结构。</p>
<ul>
<li><strong>树形结构</strong>：树、堆、哈希表，元素之间是一对多的关系。</li>
<li><strong>网状结构</strong>：图，元素之间是多对多的关系。</li>
</ul>
<div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/16.png" srcset="/img/loading.gif" lazyload alt="图片描述">
</div>


<h1 id="三、数组与链表"><a href="#三、数组与链表" class="headerlink" title="三、数组与链表"></a>三、数组与链表</h1><h2 id="1-数组-int"><a href="#1-数组-int" class="headerlink" title="1. 数组 int[]"></a>1. 数组 int[]</h2><div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/17.png" srcset="/img/loading.gif" lazyload alt="图片描述" style="zoom:50%">
</div>
#### 1.  初始化数组

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 无初始值，默认初始化为0</span><br><span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">5</span>]; <span class="hljs-comment">// &#123; 0, 0, 0, 0, 0 &#125;</span><br><span class="hljs-comment">// 给定初始值</span><br><span class="hljs-type">int</span>[] nums = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span> &#125;;<br></code></pre></td></tr></table></figure>



<h4 id="2-访问元素"><a href="#2-访问元素" class="headerlink" title="2.  访问元素"></a>2.  访问元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 整型数组</span><br><span class="hljs-type">int</span>[] array1 = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> array1[<span class="hljs-number">2</span>];<br>System.out.println(a);   <span class="hljs-comment">// 3</span><br><br><span class="hljs-comment">// 字符串形式数组</span><br>String[] array2 = &#123;<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>&#125;;<br><span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> array2[<span class="hljs-number">2</span>];<br>System.out.println(b);  <span class="hljs-comment">// c</span><br><br><span class="hljs-comment">// 循环取值</span><br>String[] array3 = &#123;<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array3.length ; i++) &#123;<br>    System.out.print(array3[i]);    <span class="hljs-comment">// abcde</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="3-添加元素"><a href="#3-添加元素" class="headerlink" title="3. 添加元素"></a>3. 添加元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test12</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;      <span class="hljs-comment">// 逻辑大小</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">capacity</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;  <span class="hljs-comment">// 容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] arry = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[capacity];  <span class="hljs-comment">// 创建静态数组</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addList</span><span class="hljs-params">(<span class="hljs-type">int</span> element)</span>&#123;<br>        arry[size] = element;<br>        size++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="3-插入元素"><a href="#3-插入元素" class="headerlink" title="3. 插入元素"></a>3. 插入元素</h4><p>如果想在数组中间插入一个元素，则需要将该元素之后的所有元素都向后移动一位，之后再把元素赋值给该索引。</p>
<div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/19.png" srcset="/img/loading.gif" lazyload alt="图片描述" style="zoom:50%">
</div>


<p>值得注意的是，由于数组的长度是固定的，因此插入一个元素必定会导致数组尾部元素“丢失”。我们将这个问题的解决方案留在“列表”章节中讨论。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 在数组的索引 index 处插入元素 num */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> num, <span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-comment">// 把索引 index 以及之后的所有元素向后移动一位</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>; i &gt; index; i--) &#123;<br>        nums[i] = nums[i - <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-comment">// 将 num 赋给 index 处的元素</span><br>    nums[index] = num;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="4-删除元素"><a href="#4-删除元素" class="headerlink" title="4. 删除元素"></a>4. 删除元素</h4><p>如下图所示，若想删除索引 i 处的元素，则需要把索引 i 之后的元素都向前移动一位。</p>
<div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/19.png" srcset="/img/loading.gif" lazyload alt="图片描述">
</div>

<p>请注意，删除元素完成后，原先末尾的元素变得“无意义”了，所以我们无须特意去修改它。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 删除索引 index 处的元素 */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-comment">// 把索引 index 之后的所有元素向前移动一位</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index; i &lt; nums.length - <span class="hljs-number">1</span>; i++) &#123;<br>        nums[i] = nums[i + <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>总的来看，数组的插入与删除操作有以下缺点。</p>
<ul>
<li><strong>时间复杂度高</strong>：数组的插入和删除的平均时间复杂度均为 O(n) ，其中 n 为数组长度。</li>
<li><strong>丢失元素</strong>：由于数组的长度不可变，因此在插入元素后，超出数组长度范围的元素会丢失。</li>
<li><strong>内存浪费</strong>：我们可以初始化一个比较长的数组，只用前面一部分，这样在插入数据时，丢失的末尾元素都是“无意义”的，但这样做会造成部分内存空间浪费。</li>
</ul>
<h4 id="5-遍历数组"><a href="#5-遍历数组" class="headerlink" title="5. 遍历数组"></a>5. 遍历数组</h4><p>在大多数编程语言中，我们既可以通过索引遍历数组，也可以直接遍历获取数组中的每个元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 遍历数组 */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">traverse</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 通过索引遍历数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        count += nums[i];<br>    &#125;<br>    <span class="hljs-comment">// 直接遍历数组元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        count += num;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="6-查找元素"><a href="#6-查找元素" class="headerlink" title="6.  查找元素"></a>6.  查找元素</h4><p>在数组中查找指定元素需要遍历数组，每轮判断元素值是否匹配，若匹配则输出对应索引。</p>
<p>因为数组是线性数据结构，所以上述查找操作被称为“线性查找”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 在数组中查找指定元素 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] == target)<br>            <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="7-扩容数组"><a href="#7-扩容数组" class="headerlink" title="7. 扩容数组"></a>7. 扩容数组</h4><p>在复杂的系统环境中，程序难以保证数组之后的内存空间是可用的，从而无法安全地扩展数组容量。因此在大多数编程语言中，<strong>数组的长度是不可变的</strong>。</p>
<p>如果我们希望扩容数组，则需重新建立一个更大的数组，然后把原数组元素依次复制到新数组。这是一个 O(n) 的操作，在数组很大的情况下非常耗时。代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 扩展数组长度 */</span><br><span class="hljs-type">int</span>[] extend(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> enlarge) &#123;<br>    <span class="hljs-comment">// 初始化一个扩展长度后的数组</span><br>    <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length + enlarge];<br>    <span class="hljs-comment">// 将原数组中的所有元素复制到新数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        res[i] = nums[i];<br>    &#125;<br>    <span class="hljs-comment">// 返回扩展后的新数组</span><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="2-链表"><a href="#2-链表" class="headerlink" title="2. 链表"></a>2. 链表</h2><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h3><p>「链表 linked list」是一种线性数据结构，其中的每个元素都是一个节点对象，各个节点通过“引用”相连接。引用记录了下一个节点的内存地址，通过它可以从当前节点访问到下一个节点</p>
<p>链表的设计使得各个节点可以分散存储在内存各处，它们的内存地址无须连续</p>
<div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/21.png" srcset="/img/loading.gif" lazyload alt="图片描述" style="zoom:60%;">
</div>



<p>如上图所示，链表的组成单位是「节点 node」对象。每个节点都包含两项数据：节点的“值”和指向下一节点的“引用”。</p>
<ul>
<li>链表的首个节点被称为“头节点”，最后一个节点被称为“尾节点”。</li>
<li>尾节点指向的是“空”，它在 Java 和 Python 中分别被记为 <code>null</code> 和 <code>None</code> 。</li>
</ul>
<ul>
<li><mark>java中没有现成的链表结构，所以链表结构需要手动构造</mark></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkList</span> &#123;<br>    <span class="hljs-type">int</span> value;  <span class="hljs-comment">// 值</span><br>    LinkList next;  <span class="hljs-comment">// 下一个节点指针</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkList</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123; value = x; &#125;  <span class="hljs-comment">// 构造函数</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="2-链表常用操作"><a href="#2-链表常用操作" class="headerlink" title="2.  链表常用操作"></a>2.  链表常用操作</h3><h4 id="1-初始化-打印链表"><a href="#1-初始化-打印链表" class="headerlink" title="1.  初始化 + 打印链表"></a>1.  初始化 + 打印链表</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkListCrud</span> &#123;<br>  <br>    <span class="hljs-comment">// 逐级打印链表</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printLinkedList</span><span class="hljs-params">(LinkList linkList)</span> &#123;<br>        <span class="hljs-type">LinkList</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> linkList;<br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">null</span>) &#123;<br>            System.out.print(current.value);<br>            current = current.next;<br>        &#125;<br>    &#125;<br>    <br>	  <span class="hljs-comment">// 构造链表</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">LinkList</span> <span class="hljs-variable">linkList1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkList</span>(<span class="hljs-number">11</span>);<br>        <span class="hljs-type">LinkList</span> <span class="hljs-variable">linkList2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkList</span>(<span class="hljs-number">22</span>);<br>        <span class="hljs-type">LinkList</span> <span class="hljs-variable">linkList3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkList</span>(<span class="hljs-number">33</span>);<br><br>        linkList1.next = linkList2;<br>        linkList2.next = linkList3;<br><br>        printLinkedList(linkList1);  <span class="hljs-comment">// 112233</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="2-插入节点"><a href="#2-插入节点" class="headerlink" title="2.  插入节点"></a>2.  插入节点</h4><div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/22.png" srcset="/img/loading.gif" lazyload alt="图片描述" style="zoom:60%;">
</div>


<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 在链表的节点 n0 之后插入节点 P ，只需要改变两个节点引用*/</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(ListNode n0, ListNode P)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> n0.next;<br>    P.next = n1;<br>    n0.next = P;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="3-删除节点"><a href="#3-删除节点" class="headerlink" title="3.  删除节点"></a>3.  删除节点</h4><p><strong>删除节点只需改变一个节点的引用（指针）即可</strong>。尽管在删除操作完成后节点 <code>P</code> 仍然指向 <code>n1</code> ，但实际上遍历此链表已经无法访问到 <code>P</code> ，这意味着 <code>P</code> 已经不再属于该链表了。</p>
<div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/23.png" srcset="/img/loading.gif" lazyload alt="图片描述">
</div>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 删除链表的节点 n0 之后的首个节点 */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(ListNode n0)</span> &#123;<br>    <span class="hljs-keyword">if</span> (n0.next == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// n0 -&gt; P -&gt; n1</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">P</span> <span class="hljs-operator">=</span> n0.next;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> P.next;<br>    n0.next = n1;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="4-访问节点"><a href="#4-访问节点" class="headerlink" title="4.  访问节点"></a>4.  访问节点</h4><p><strong>在链表中访问节点的效率较低</strong>。如上一节所述，我们可以在 O(1) 时间下访问数组中的任意元素。链表则不然，程序需要从头节点出发，逐个向后遍历，直至找到目标节点。也就是说，访问链表的第 i 个节点需要循环 i−1 轮，时间复杂度为 O(n) 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 访问链表中索引为 index 的节点 */</span><br>ListNode <span class="hljs-title function_">access</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; index; i++) &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        head = head.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="5-查找节点"><a href="#5-查找节点" class="headerlink" title="5.  查找节点"></a>5.  查找节点</h4><p>遍历链表，查找其中值为 <code>target</code> 的节点，输出该节点在链表中的索引。此过程也属于线性查找。代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 在链表中查找值为 target 的首个节点 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (head.val == target)<br>            <span class="hljs-keyword">return</span> index;<br>        head = head.next;<br>        index++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="3-常见链表类型"><a href="#3-常见链表类型" class="headerlink" title="3.  常见链表类型"></a>3.  常见链表类型</h3><ul>
<li><strong>单向链表</strong>：即前面介绍的普通链表。单向链表的节点包含值和指向下一节点的引用两项数据。我们将首个节点称为头节点，将最后一个节点称为尾节点，尾节点指向空 <code>None</code> 。</li>
<li><strong>环形链表</strong>：如果我们令单向链表的尾节点指向头节点（首尾相接），则得到一个环形链表。在环形链表中，任意节点都可以视作头节点。</li>
<li><strong>双向链表</strong>：与单向链表相比，双向链表记录了两个方向的引用。双向链表的节点定义同时包含指向后继节点（下一个节点）和前驱节点（上一个节点）的引用（指针）。相较于单向链表，双向链表更具灵活性，可以朝两个方向遍历链表，但相应地也需要占用更多的内存空间。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 双向链表节点类 */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-type">int</span> val;        <span class="hljs-comment">// 节点值</span><br>    ListNode next;  <span class="hljs-comment">// 指向后继节点的引用</span><br>    ListNode prev;  <span class="hljs-comment">// 指向前驱节点的引用</span><br>    ListNode(<span class="hljs-type">int</span> x) &#123; val = x; &#125;  <span class="hljs-comment">// 构造函数</span><br>&#125;<br></code></pre></td></tr></table></figure>

<div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/24.png" srcset="/img/loading.gif" lazyload alt="图片描述">
</div>



<h3 id="4-链表典型应用"><a href="#4-链表典型应用" class="headerlink" title="4.  链表典型应用"></a>4.  链表典型应用</h3><p>单向链表通常用于实现栈、队列、哈希表和图等数据结构。</p>
<ul>
<li><strong>栈与队列</strong>：当插入和删除操作都在链表的一端进行时，它表现出先进后出的特性，对应栈；当插入操作在链表的一端进行，删除操作在链表的另一端进行，它表现出先进先出的特性，对应队列。</li>
<li><strong>哈希表</strong>：链式地址是解决哈希冲突的主流方案之一，在该方案中，所有冲突的元素都会被放到一个链表中。</li>
<li><strong>图</strong>：邻接表是表示图的一种常用方式，其中图的每个顶点都与一个链表相关联，链表中的每个元素都代表与该顶点相连的其他顶点。</li>
</ul>
<p>双向链表常用于需要快速查找前一个和后一个元素的场景。</p>
<ul>
<li><strong>高级数据结构</strong>：比如在红黑树、B 树中，我们需要访问节点的父节点，这可以通过在节点中保存一个指向父节点的引用来实现，类似于双向链表。</li>
<li><strong>浏览器历史</strong>：在网页浏览器中，当用户点击前进或后退按钮时，浏览器需要知道用户访问过的前一个和后一个网页。双向链表的特性使得这种操作变得简单。</li>
<li><strong>LRU 算法</strong>：在缓存淘汰（LRU）算法中，我们需要快速找到最近最少使用的数据，以及支持快速添加和删除节点。这时候使用双向链表就非常合适。</li>
</ul>
<h2 id="3-列表-ArrayList"><a href="#3-列表-ArrayList" class="headerlink" title="3. 列表 ArrayList&lt;&gt;"></a>3. 列表 ArrayList&lt;&gt;</h2><p>列表表示元素的有序集合，支持元素访问、修改、添加、删除和遍历等操作，无须使用者考虑容量限制的问题。列表可以基于链表或数组实现。</p>
<ul>
<li>链表天然可以看作一个列表，其支持元素增删查改操作，并且可以灵活动态扩容。</li>
<li>数组也支持元素增删查改，但由于其长度不可变，因此只能看作一个具有长度限制的列表。</li>
</ul>
<p>当使用数组实现列表时，<strong>长度不可变的性质会导致列表的实用性降低</strong>。这是因为我们通常无法事先确定需要存储多少数据，从而难以选择合适的列表长度。</p>
<p><mark>列表的概念相当于动态数组，需要先创建数组，然后在将其动态化</mark></p>
<h3 id="1-列表常用操作"><a href="#1-列表常用操作" class="headerlink" title="1.  列表常用操作"></a>1.  列表常用操作</h3><h4 id="1-初始化列表"><a href="#1-初始化列表" class="headerlink" title="1.  初始化列表"></a>1.  初始化列表</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 初始化列表 */</span><br><span class="hljs-comment">// 无初始值</span><br>List&lt;Integer&gt; nums1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br><span class="hljs-comment">// 有初始值（注意数组的元素类型需为 int[] 的包装类 Integer[]）</span><br><span class="hljs-comment">// 先创建数组</span><br>Integer[] numbers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[] &#123; <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span> &#125;;<br><span class="hljs-comment">// 再将数组动态化</span><br>List&lt;Integer&gt; nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(numbers));<br></code></pre></td></tr></table></figure>



<h3 id="2-访问元素-1"><a href="#2-访问元素-1" class="headerlink" title="2.  访问元素"></a>2.  访问元素</h3><p>列表本质上是数组，因此可以在 O(1) 时间内访问和更新元素，效率很高。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 访问元素 */</span><br><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> nums.get(<span class="hljs-number">1</span>);  <span class="hljs-comment">// 访问索引 1 处的元素</span><br><br><span class="hljs-comment">/* 更新元素 */</span><br>nums.set(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);  <span class="hljs-comment">// 将索引 1 处的元素更新为 0</span><br></code></pre></td></tr></table></figure>



<h3 id="3-插入与删除元素"><a href="#3-插入与删除元素" class="headerlink" title="3.  插入与删除元素"></a>3.  插入与删除元素</h3><p>相较于数组，列表可以自由地添加与删除元素。在列表尾部添加元素的时间复杂度为 O(1) ，但插入和删除元素的效率仍与数组相同，时间复杂度为 O(n) 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 清空列表 */</span><br>nums.clear();<br><br><span class="hljs-comment">/* 在尾部添加元素 */</span><br>nums.add(<span class="hljs-number">1</span>);<br>nums.add(<span class="hljs-number">3</span>);<br>nums.add(<span class="hljs-number">2</span>);<br>nums.add(<span class="hljs-number">5</span>);<br>nums.add(<span class="hljs-number">4</span>);<br><br><span class="hljs-comment">/* 在中间插入元素 */</span><br>nums.add(<span class="hljs-number">3</span>, <span class="hljs-number">6</span>);  <span class="hljs-comment">// 在索引 3 处插入数字 6</span><br><br><span class="hljs-comment">/* 删除元素 */</span><br>nums.remove(<span class="hljs-number">3</span>);  <span class="hljs-comment">// 删除索引 3 处的元素</span><br></code></pre></td></tr></table></figure>



<h3 id="4-遍历列表"><a href="#4-遍历列表" class="headerlink" title="4.  遍历列表"></a>4.  遍历列表</h3><p>与数组一样，列表可以根据索引遍历，也可以直接遍历各元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 通过索引遍历列表 */</span><br><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.size(); i++) &#123;<br>    count += nums.get(i);<br>&#125;<br><br><span class="hljs-comment">/* 直接遍历列表元素 */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>    count += num;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="5-拼接列表"><a href="#5-拼接列表" class="headerlink" title="5.  拼接列表"></a>5.  拼接列表</h3><p>给定一个新列表 <code>nums1</code> ，我们可以将其拼接到原列表的尾部</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 拼接两个列表 */</span><br>List&lt;Integer&gt; nums1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[] &#123; <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">10</span>, <span class="hljs-number">9</span> &#125;));<br>nums.addAll(nums1);  <span class="hljs-comment">// 将列表 nums1 拼接到 nums 之后</span><br></code></pre></td></tr></table></figure>



<h3 id="6-排序列表"><a href="#6-排序列表" class="headerlink" title="6.  排序列表"></a>6.  排序列表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 排序列表 */</span><br>Collections.sort(nums);  <span class="hljs-comment">// 排序后，列表元素从小到大排列</span><br></code></pre></td></tr></table></figure>

<div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/25.png" srcset="/img/loading.gif" lazyload alt="图片描述" style="zoom:35%;">
</div>



<h1 id="四、栈与队列"><a href="#四、栈与队列" class="headerlink" title="四、栈与队列"></a>四、栈与队列</h1><h2 id="1-栈-stack"><a href="#1-栈-stack" class="headerlink" title="1. 栈 stack"></a>1. 栈 stack</h2><div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/26.png" srcset="/img/loading.gif" lazyload alt="图片描述" style="zoom:60%;">
</div>


<h3 id="1-栈的常用操作"><a href="#1-栈的常用操作" class="headerlink" title="1.栈的常用操作"></a>1.栈的常用操作</h3><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td><code>push()</code></td>
<td>元素入栈（添加至栈顶）</td>
<td><code>O(1)</code></td>
</tr>
<tr>
<td><code>pop()</code></td>
<td>栈顶元素出栈</td>
<td><code>O(1)</code></td>
</tr>
<tr>
<td><code>peek()</code></td>
<td>访问栈顶元素</td>
<td><code>O(1)</code></td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 初始化栈 */</span><br>Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br><br><span class="hljs-comment">/* 元素入栈 */</span><br>stack.push(<span class="hljs-number">1</span>);<br>stack.push(<span class="hljs-number">3</span>);<br>stack.push(<span class="hljs-number">2</span>);<br>stack.push(<span class="hljs-number">5</span>);<br>stack.push(<span class="hljs-number">4</span>);<br><br><span class="hljs-comment">/* 访问栈顶元素 */</span><br><span class="hljs-type">int</span> <span class="hljs-variable">peek</span> <span class="hljs-operator">=</span> stack.peek();<br><br><span class="hljs-comment">/* 元素出栈 */</span><br><span class="hljs-type">int</span> <span class="hljs-variable">pop</span> <span class="hljs-operator">=</span> stack.pop();<br><br><span class="hljs-comment">/* 获取栈的长度 */</span><br><span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> stack.size();<br><br><span class="hljs-comment">/* 判断是否为空 */</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">isEmpty</span> <span class="hljs-operator">=</span> stack.isEmpty();<br></code></pre></td></tr></table></figure>



<h3 id="2-栈的典型应用"><a href="#2-栈的典型应用" class="headerlink" title="2.栈的典型应用"></a>2.栈的典型应用</h3><ul>
<li><strong>浏览器中的后退与前进、软件中的撤销与反撤销</strong>。每当我们打开新的网页，浏览器就会对上一个网页执行入栈，这样我们就可以通过后退操作回到上一个网页。后退操作实际上是在执行出栈。如果要同时支持后退和前进，那么需要两个栈来配合实现。</li>
<li><strong>程序内存管理</strong>。每次调用函数时，系统都会在栈顶添加一个栈帧，用于记录函数的上下文信息。在递归函数中，向下递推阶段会不断执行入栈操作，而向上回溯阶段则会不断执行出栈操作。</li>
</ul>
<h2 id="2-队列-LinkedList"><a href="#2-队列-LinkedList" class="headerlink" title="2. 队列 LinkedList"></a>2. 队列 LinkedList</h2><div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/27.png" srcset="/img/loading.gif" lazyload alt="图片描述" style="zoom:100%;">
</div>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 初始化队列 */</span><br>Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br><span class="hljs-comment">/* 元素入队 */</span><br>queue.offer(<span class="hljs-number">1</span>);<br>queue.offer(<span class="hljs-number">3</span>);<br>queue.offer(<span class="hljs-number">2</span>);<br>queue.offer(<span class="hljs-number">5</span>);<br>queue.offer(<span class="hljs-number">4</span>);<br><br><span class="hljs-comment">/* 访问队首元素 */</span><br><span class="hljs-type">int</span> <span class="hljs-variable">peek</span> <span class="hljs-operator">=</span> queue.peek();<br><br><span class="hljs-comment">/* 元素出队 */</span><br><span class="hljs-type">int</span> <span class="hljs-variable">pop</span> <span class="hljs-operator">=</span> queue.poll();<br><br><span class="hljs-comment">/* 获取队列的长度 */</span><br><span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br><br><span class="hljs-comment">/* 判断队列是否为空 */</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">isEmpty</span> <span class="hljs-operator">=</span> queue.isEmpty();<br></code></pre></td></tr></table></figure>



<h3 id="1-队列的常用操作"><a href="#1-队列的常用操作" class="headerlink" title="1.队列的常用操作"></a>1.队列的常用操作</h3><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td><code>offer()</code></td>
<td>元素入队，即将元素添加至队尾</td>
<td><code>O(1)</code></td>
</tr>
<tr>
<td><code>poll()</code></td>
<td>队首元素出队</td>
<td><code>O(1)</code></td>
</tr>
<tr>
<td><code>peek()</code></td>
<td>访问队首元素</td>
<td><code>O(1)</code></td>
</tr>
</tbody></table>
<h3 id="2-队列典型应用"><a href="#2-队列典型应用" class="headerlink" title="2.  队列典型应用"></a>2.  队列典型应用</h3><ul>
<li><strong>淘宝订单</strong>。购物者下单后，订单将加入队列中，系统随后会根据顺序处理队列中的订单。在双十一期间，短时间内会产生海量订单，高并发成为工程师们需要重点攻克的问题。</li>
<li><strong>各类待办事项</strong>。任何需要实现“先来后到”功能的场景，例如打印机的任务队列、餐厅的出餐队列等，队列在这些场景中可以有效地维护处理顺序。</li>
</ul>
<h2 id="3-双向队列"><a href="#3-双向队列" class="headerlink" title="3.双向队列"></a>3.双向队列</h2><div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/28.png" srcset="/img/loading.gif" lazyload alt="图片描述" style="zoom:100%;">
</div>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 初始化双向队列 */</span><br>Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br><span class="hljs-comment">/* 元素入队 */</span><br>deque.offerLast(<span class="hljs-number">2</span>);   <span class="hljs-comment">// 添加至队尾</span><br>deque.offerLast(<span class="hljs-number">5</span>);<br>deque.offerLast(<span class="hljs-number">4</span>);<br>deque.offerFirst(<span class="hljs-number">3</span>);  <span class="hljs-comment">// 添加至队首</span><br>deque.offerFirst(<span class="hljs-number">1</span>);<br><br><span class="hljs-comment">/* 访问元素 */</span><br><span class="hljs-type">int</span> <span class="hljs-variable">peekFirst</span> <span class="hljs-operator">=</span> deque.peekFirst();  <span class="hljs-comment">// 队首元素</span><br><span class="hljs-type">int</span> <span class="hljs-variable">peekLast</span> <span class="hljs-operator">=</span> deque.peekLast();    <span class="hljs-comment">// 队尾元素</span><br><br><span class="hljs-comment">/* 元素出队 */</span><br><span class="hljs-type">int</span> <span class="hljs-variable">popFirst</span> <span class="hljs-operator">=</span> deque.pollFirst();  <span class="hljs-comment">// 队首元素出队</span><br><span class="hljs-type">int</span> <span class="hljs-variable">popLast</span> <span class="hljs-operator">=</span> deque.pollLast();    <span class="hljs-comment">// 队尾元素出队</span><br><br><span class="hljs-comment">/* 获取双向队列的长度 */</span><br><span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> deque.size();<br><br><span class="hljs-comment">/* 判断双向队列是否为空 */</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">isEmpty</span> <span class="hljs-operator">=</span> deque.isEmpty();<br></code></pre></td></tr></table></figure>



<h3 id="1-双向队列的常用操作"><a href="#1-双向队列的常用操作" class="headerlink" title="1.双向队列的常用操作"></a>1.双向队列的常用操作</h3><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td><code>push_first()</code></td>
<td>将元素添加至队首</td>
<td><code>O(1)</code></td>
</tr>
<tr>
<td><code>push_last()</code></td>
<td>将元素添加至队尾</td>
<td><code>O(1)</code></td>
</tr>
<tr>
<td><code>pop_first()</code></td>
<td>删除队首元素</td>
<td><code>O(1)</code></td>
</tr>
<tr>
<td><code>pop_last()</code></td>
<td>删除队尾元素</td>
<td><code>O(1)</code></td>
</tr>
<tr>
<td><code>peek_first()</code></td>
<td>访问队首元素</td>
<td><code>O(1)</code></td>
</tr>
<tr>
<td><code>peek_last()</code></td>
<td>访问队尾元素</td>
<td><code>O(1)</code></td>
</tr>
</tbody></table>
<h3 id="2-双向队列的典型应用"><a href="#2-双向队列的典型应用" class="headerlink" title="2.双向队列的典型应用"></a>2.双向队列的典型应用</h3><p>双向队列兼具栈与队列的逻辑，<strong>因此它可以实现这两者的所有应用场景，同时提供更高的自由度</strong>。</p>
<p>我们知道，软件的“撤销”功能通常使用栈来实现：系统将每次更改操作 <code>push</code> 到栈中，然后通过 <code>pop</code> 实现撤销。然而，考虑到系统资源的限制，软件通常会限制撤销的步数（例如仅允许保存 50 步）。当栈的长度超过 50 时，软件需要在栈底（队首）执行删除操作。<strong>但栈无法实现该功能，此时就需要使用双向队列来替代栈</strong>。请注意，“撤销”的核心逻辑仍然遵循栈的先入后出原则，只是双向队列能够更加灵活地实现一些额外逻辑。</p>
<h1 id="五、哈希表"><a href="#五、哈希表" class="headerlink" title="五、哈希表"></a>五、哈希表</h1><div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/29.png" srcset="/img/loading.gif" lazyload alt="图片描述" style="zoom:60%;">
</div>


<ul>
<li><strong>添加元素</strong>：仅需将元素添加至数组（链表）的尾部即可，使用 O(1) 时间。</li>
<li><strong>查询元素</strong>：由于数组（链表）是乱序的，因此需要遍历其中的所有元素，使用 O(n) 时间。</li>
<li><strong>删除元素</strong>：需要先查询到元素，再从数组（链表）中删除，使用 O(n) 时间。</li>
</ul>
<p>表 6-1  元素查询效率对比</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">数组</th>
<th align="left">链表</th>
<th align="left">哈希表</th>
</tr>
</thead>
<tbody><tr>
<td align="left">查找元素</td>
<td align="left">O(n)</td>
<td align="left">O(n)</td>
<td align="left">O(1)</td>
</tr>
<tr>
<td align="left">添加元素</td>
<td align="left">O(1)</td>
<td align="left">O(1)</td>
<td align="left">O(1)</td>
</tr>
<tr>
<td align="left">删除元素</td>
<td align="left">O(n)</td>
<td align="left">O(n)</td>
<td align="left">O(1)</td>
</tr>
</tbody></table>
<p><strong>在哈希表中进行增删查改的时间复杂度都是 O(1)</strong> ，非常高效</p>
<p>1.哈希表的常用操作：初始化、查询操作、添加键值对和删除键值对等：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 初始化哈希表 */</span><br>Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br><span class="hljs-comment">/* 添加操作 */</span><br><span class="hljs-comment">// 在哈希表中添加键值对 (key, value)</span><br>map.put(<span class="hljs-number">12836</span>, <span class="hljs-string">&quot;小哈&quot;</span>);<br>map.put(<span class="hljs-number">15937</span>, <span class="hljs-string">&quot;小啰&quot;</span>);<br>map.put(<span class="hljs-number">16750</span>, <span class="hljs-string">&quot;小算&quot;</span>);<br>map.put(<span class="hljs-number">13276</span>, <span class="hljs-string">&quot;小法&quot;</span>);<br>map.put(<span class="hljs-number">10583</span>, <span class="hljs-string">&quot;小鸭&quot;</span>);<br><br><span class="hljs-comment">/* 查询操作 */</span><br><span class="hljs-comment">// 向哈希表中输入键 key ，得到值 value</span><br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> map.get(<span class="hljs-number">15937</span>);<br><br><span class="hljs-comment">/* 删除操作 */</span><br><span class="hljs-comment">// 在哈希表中删除键值对 (key, value)</span><br>map.remove(<span class="hljs-number">10583</span>);<br></code></pre></td></tr></table></figure>

<p>哈希表有三种常用的遍历方式：遍历键值对、遍历键和遍历值。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 遍历哈希表 */</span><br><span class="hljs-comment">// 遍历键值对 key-&gt;value</span><br><span class="hljs-keyword">for</span> (Map.Entry &lt;Integer, String&gt; kv: map.entrySet()) &#123;<br>    System.out.println(kv.getKey() + <span class="hljs-string">&quot; -&gt; &quot;</span> + kv.getValue());<br>&#125;<br><span class="hljs-comment">// 单独遍历键 key</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> key: map.keySet()) &#123;<br>    System.out.println(key);<br>&#125;<br><span class="hljs-comment">// 单独遍历值 value</span><br><span class="hljs-keyword">for</span> (String val: map.values()) &#123;<br>    System.out.println(val);<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="六、树"><a href="#六、树" class="headerlink" title="六、树"></a>六、树</h1><p>二叉树（binary tree）是一种非线性数据结构，代表“祖先”与“后代”之间的派生关系，体现了“一分为二”的分治逻辑。与链表类似，二叉树的基本单元是节点，每个节点包含值、左子节点引用和右子节点引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 二叉树节点类 */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>    <span class="hljs-type">int</span> val;         <span class="hljs-comment">// 节点值</span><br>    TreeNode left;   <span class="hljs-comment">// 左子节点引用</span><br>    TreeNode right;  <span class="hljs-comment">// 右子节点引用</span><br>    TreeNode(<span class="hljs-type">int</span> x) &#123; val = x; &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>每个节点都有两个引用（指针），分别指向左子节点（left-child node）和右子节点（right-child node），该节点被称为这两个子节点的父节点（parent node）。当给定一个二叉树的节点时，我们将该节点的左子节点及其以下节点形成的树称为该节点的左子树（left subtree），同理可得右子树（right subtree）。</p>
<p><strong>在二叉树中，除叶节点外，其他所有节点都包含子节点和非空子树</strong>。如图 7-1 所示，如果将“节点 2”视为父节点，则其左子节点和右子节点分别是“节点 4”和“节点 5”，左子树是“节点 4 及其以下节点形成的树”，右子树是“节点 5 及其以下节点形成的树”。</p>
<div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/30.png" srcset="/img/loading.gif" lazyload alt="图片描述" style="zoom:60%;">
</div>

<h2 id="1-二叉树"><a href="#1-二叉树" class="headerlink" title="1.二叉树"></a>1.二叉树</h2><h3 id="1-二叉树常见术语"><a href="#1-二叉树常见术语" class="headerlink" title="1.二叉树常见术语"></a>1.二叉树常见术语</h3><ul>
<li>根节点（root node）：位于二叉树顶层的节点，没有父节点。</li>
<li>叶节点（leaf node）：没有子节点的节点，其两个指针均指向 <code>None</code> 。</li>
<li>边（edge）：连接两个节点的线段，即节点引用（指针）。</li>
<li>节点所在的层（level）：从顶至底递增，根节点所在层为 1 。</li>
<li>节点的度（degree）：节点的子节点的数量。在二叉树中，度的取值范围是 0、1、2 。</li>
<li>二叉树的高度（height）：从根节点到最远叶节点所经过的边的数量。</li>
<li>节点的深度（depth）：从根节点到该节点所经过的边的数量。</li>
<li>节点的高度（height）：从距离该节点最远的叶节点到该节点所经过的边的数量。3</li>
</ul>
<div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/31.png" srcset="/img/loading.gif" lazyload alt="图片描述" style="zoom:60%;">
</div>



<h3 id="2-二叉树基本操作"><a href="#2-二叉树基本操作" class="headerlink" title="2.二叉树基本操作"></a>2.二叉树基本操作</h3><h4 id="1-初始化二叉树"><a href="#1-初始化二叉树" class="headerlink" title="1. 初始化二叉树"></a>1. 初始化二叉树</h4><p>与链表类似，首先初始化节点，然后构建引用（指针）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 初始化节点</span><br><span class="hljs-type">TreeNode</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">1</span>);<br><span class="hljs-type">TreeNode</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">2</span>);<br><span class="hljs-type">TreeNode</span> <span class="hljs-variable">n3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">3</span>);<br><span class="hljs-type">TreeNode</span> <span class="hljs-variable">n4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">4</span>);<br><span class="hljs-type">TreeNode</span> <span class="hljs-variable">n5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">5</span>);<br><span class="hljs-comment">// 构建节点之间的引用（指针）</span><br>n1.left = n2;<br>n1.right = n3;<br>n2.left = n4;<br>n2.right = n5;<br></code></pre></td></tr></table></figure>



<h4 id="2-插入与删除节点"><a href="#2-插入与删除节点" class="headerlink" title="2.插入与删除节点"></a>2.插入与删除节点</h4><p>与链表类似，在二叉树中插入与删除节点可以通过修改指针来实现</p>
<ul>
<li>需要注意的是，插入节点可能会改变二叉树的原有逻辑结构，而删除节点通常意味着删除该节点及其所有子树。因此，在二叉树中，插入与删除通常是由一套操作配合完成的，以实现有实际意义的操作。</li>
</ul>
<div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/32.png" srcset="/img/loading.gif" lazyload alt="图片描述" style="zoom:60%;">
</div>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">TreeNode</span> <span class="hljs-variable">P</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">0</span>);<br><span class="hljs-comment">// 在 n1 -&gt; n2 中间插入节点 P</span><br>n1.left = P;<br>P.left = n2;<br><span class="hljs-comment">// 删除节点 P</span><br>n1.left = n2;<br></code></pre></td></tr></table></figure>



<h3 id="3-常见二叉树类型"><a href="#3-常见二叉树类型" class="headerlink" title="3.常见二叉树类型"></a>3.常见二叉树类型</h3><h4 id="1-完美二叉树"><a href="#1-完美二叉树" class="headerlink" title="1.完美二叉树"></a>1.完美二叉树</h4><p>完美二叉树（perfect binary tree）所有层的节点都被完全填满。在完美二叉树中，叶节点的度为 0 ，其余所有节点的度都为 2 ；若树的高度为 h ，则节点总数为 2h+1−1 ，呈现标准的指数级关系，反映了自然界中常见的细胞分裂现象</p>
<div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/33.png" srcset="/img/loading.gif" lazyload alt="图片描述" style="zoom:60%;">
</div>

<h4 id="2-完全二叉树"><a href="#2-完全二叉树" class="headerlink" title="2.  完全二叉树"></a>2.  完全二叉树</h4><p>完全二叉树（complete binary tree）仅允许最底层的节点不完全填满，且最底层的节点必须从左至右依次连续填充。请注意，完美二叉树也是一棵完全二叉树</p>
<div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/34.png" srcset="/img/loading.gif" lazyload alt="图片描述" style="zoom:60%;">
</div>

<h4 id="3-完满二叉树"><a href="#3-完满二叉树" class="headerlink" title="3.  完满二叉树"></a>3.  完满二叉树</h4><p>完满二叉树（full binary tree）除了叶节点之外，其余所有节点都有两个子节点</p>
<div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/35.png" srcset="/img/loading.gif" lazyload alt="图片描述" style="zoom:60%;">
</div>

<h4 id="4-平衡二叉树"><a href="#4-平衡二叉树" class="headerlink" title="4.  平衡二叉树"></a>4.  平衡二叉树</h4><p>平衡二叉树（balanced binary tree）中任意节点的左子树和右子树的高度之差的绝对值不超过 1</p>
<div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/36.png" srcset="/img/loading.gif" lazyload alt="图片描述" style="zoom:60%;">
</div>



<h2 id="2-二叉树遍历"><a href="#2-二叉树遍历" class="headerlink" title="2.二叉树遍历"></a>2.二叉树遍历</h2><p>从物理结构的角度来看，树是一种基于链表的数据结构，因此其遍历方式是通过指针逐个访问节点。然而，树是一种非线性数据结构，这使得遍历树比遍历链表更加复杂，需要借助搜索算法来实现。</p>
<p>二叉树常见的遍历方式包括层序遍历、前序遍历、中序遍历和后序遍历等</p>
<h3 id="1-层序遍历"><a href="#1-层序遍历" class="headerlink" title="1.层序遍历"></a>1.层序遍历</h3><p>层序遍历（level-order traversal）从顶部到底部逐层遍历二叉树，并在每一层按照从左到右的顺序访问节点。</p>
<p>层序遍历本质上属于广度优先遍历（breadth-first traversal），也称广度优先搜索（breadth-first search, BFS），它体现了一种“一圈一圈向外扩展”的逐层遍历方式</p>
<div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/37.png" srcset="/img/loading.gif" lazyload alt="图片描述" style="zoom:60%;">
</div>

<p>广度优先遍历通常借助“队列”来实现。队列遵循“先进先出”的规则，而广度优先遍历则遵循“逐层推进”的规则，两者背后的思想是一致的。实现代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 层序遍历 */</span><br>List&lt;Integer&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-comment">// 初始化队列，加入根节点</span><br>    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    queue.add(root);<br>    <span class="hljs-comment">// 初始化一个列表，用于保存遍历序列</span><br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll(); <span class="hljs-comment">// 队列出队</span><br>        list.add(node.val);           <span class="hljs-comment">// 保存节点值</span><br>        <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>)<br>            queue.offer(node.left);   <span class="hljs-comment">// 左子节点入队</span><br>        <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>)<br>            queue.offer(node.right);  <span class="hljs-comment">// 右子节点入队</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> list;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="2-前序、中序、后序遍历"><a href="#2-前序、中序、后序遍历" class="headerlink" title="2.前序、中序、后序遍历"></a>2.前序、中序、后序遍历</h3><p>相应地，前序、中序和后序遍历都属于深度优先遍历（depth-first traversal），也称深度优先搜索（depth-first search, DFS），它体现了一种“先走到尽头，再回溯继续”的遍历方式。</p>
<p>图 7-10 展示了对二叉树进行深度优先遍历的工作原理。<strong>深度优先遍历就像是绕着整棵二叉树的外围“走”一圈</strong>，在每个节点都会遇到三个位置，分别对应前序遍历、中序遍历和后序遍历</p>
<div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/38.png" srcset="/img/loading.gif" lazyload alt="图片描述" style="zoom:60%;">
</div>

<p>深度优先搜索通常基于递归实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 前序遍历 */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">preOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 访问优先级：根节点 -&gt; 左子树 -&gt; 右子树</span><br>    list.add(root.val);<br>    preOrder(root.left);<br>    preOrder(root.right);<br>&#125;<br><br><span class="hljs-comment">/* 中序遍历 */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">inOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 访问优先级：左子树 -&gt; 根节点 -&gt; 右子树</span><br>    inOrder(root.left);<br>    list.add(root.val);<br>    inOrder(root.right);<br>&#125;<br><br><span class="hljs-comment">/* 后序遍历 */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">postOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 访问优先级：左子树 -&gt; 右子树 -&gt; 根节点</span><br>    postOrder(root.left);<br>    postOrder(root.right);<br>    list.add(root.val);<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="七、堆"><a href="#七、堆" class="headerlink" title="七、堆"></a>七、堆</h1><h2 id="1-堆"><a href="#1-堆" class="headerlink" title="1.堆"></a>1.堆</h2><p><mark>堆（heap）是一种满足特定条件的完全二叉树</mark>，主要可分为两种类型</p>
<ul>
<li><mark>小顶堆</mark>（min heap）：任意节点的值 ≤ 其子节点的值，<mark>顶堆元素的值是最小的</mark></li>
<li><mark>大顶堆</mark>（max heap）：任意节点的值 ≥ 其子节点的值，<mark>顶堆元素的值是最大的</mark></li>
</ul>
<div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/39.png" srcset="/img/loading.gif" lazyload alt="图片描述" style="zoom:60%;">
</div>

<p>堆作为完全二叉树的一个特例，具有以下特性。</p>
<ul>
<li>最底层节点靠左填充，其他层的节点都被填满。</li>
<li>我们将二叉树的根节点称为“堆顶”，将底层最靠右的节点称为“堆底”。</li>
</ul>
<h3 id="1-堆的常用操作"><a href="#1-堆的常用操作" class="headerlink" title="1. 堆的常用操作"></a>1. 堆的常用操作</h3><p>需要指出的是，许多编程语言提供的是优先队列（priority queue），这是一种抽象的数据结构，定义为具有优先级排序的队列。</p>
<p>实际上，<strong>堆通常用于实现优先队列，大顶堆相当于元素按从大到小的顺序出队的优先队列</strong>。从使用角度来看，我们可以将“优先队列”和“堆”看作等价的数据结构。因此，本书对两者不做特别区分，统一称作“堆”。</p>
<table>
<thead>
<tr>
<th align="left">方法名</th>
<th align="left">描述</th>
<th align="left">时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>push()</code></td>
<td align="left">元素入堆</td>
<td align="left">O(log⁡n)</td>
</tr>
<tr>
<td align="left"><code>pop()</code></td>
<td align="left">堆顶元素出堆</td>
<td align="left">O(log⁡n)</td>
</tr>
<tr>
<td align="left"><code>peek()</code></td>
<td align="left">访问堆顶元素（对于大 &#x2F; 小顶堆分别为最大 &#x2F; 小值）</td>
<td align="left">O(1)</td>
</tr>
<tr>
<td align="left"><code>size()</code></td>
<td align="left">获取堆的元素数量</td>
<td align="left">O(1)</td>
</tr>
<tr>
<td align="left"><code>isEmpty()</code></td>
<td align="left">判断堆是否为空</td>
<td align="left">O(1)</td>
</tr>
</tbody></table>
<p>类似于排序算法中的“从小到大排列”和“从大到小排列”，我们可以通过设置一个 <code>flag</code> 或修改 <code>Comparator</code> 实现“小顶堆”与“大顶堆”之间的转换。代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 初始化堆 */</span><br><span class="hljs-comment">// 初始化小顶堆</span><br>Queue&lt;Integer&gt; minHeap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br><span class="hljs-comment">// 初始化大顶堆（使用 lambda 表达式修改 Comparator 即可）</span><br>Queue&lt;Integer&gt; maxHeap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; b - a);<br><br><span class="hljs-comment">/* 元素入堆 */</span><br>maxHeap.offer(<span class="hljs-number">1</span>);<br>maxHeap.offer(<span class="hljs-number">3</span>);<br>maxHeap.offer(<span class="hljs-number">2</span>);<br>maxHeap.offer(<span class="hljs-number">5</span>);<br>maxHeap.offer(<span class="hljs-number">4</span>);<br><br><span class="hljs-comment">/* 获取堆顶元素 */</span><br><span class="hljs-type">int</span> <span class="hljs-variable">peek</span> <span class="hljs-operator">=</span> maxHeap.peek(); <span class="hljs-comment">// 5</span><br><br><span class="hljs-comment">/* 堆顶元素出堆 */</span><br><span class="hljs-comment">// 出堆元素会形成一个从大到小的序列</span><br>peek = maxHeap.poll(); <span class="hljs-comment">// 5</span><br>peek = maxHeap.poll(); <span class="hljs-comment">// 4</span><br>peek = maxHeap.poll(); <span class="hljs-comment">// 3</span><br>peek = maxHeap.poll(); <span class="hljs-comment">// 2</span><br>peek = maxHeap.poll(); <span class="hljs-comment">// 1</span><br><br><span class="hljs-comment">/* 获取堆大小 */</span><br><span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> maxHeap.size();<br><br><span class="hljs-comment">/* 判断堆是否为空 */</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">isEmpty</span> <span class="hljs-operator">=</span> maxHeap.isEmpty();<br><br><span class="hljs-comment">/* 输入列表并建堆 */</span><br>minHeap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>));<br></code></pre></td></tr></table></figure>



<h2 id="2-Top-k问题"><a href="#2-Top-k问题" class="headerlink" title="2.Top-k问题"></a>2.Top-k问题</h2><blockquote>
<p>[!NOTE]</p>
<p>给定一个长度为 n 的无序数组 <code>nums</code> ，请返回数组中最大的 k 个元素</p>
</blockquote>
<h3 id="1-方法1：遍历选择"><a href="#1-方法1：遍历选择" class="headerlink" title="1.方法1：遍历选择"></a>1.方法1：遍历选择</h3><p>k 轮遍历，分别在每轮中提取第 1、2、…、k 大的元素，时间复杂度为 O(nk) </p>
<div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/40.png" srcset="/img/loading.gif" lazyload alt="图片描述" style="zoom:60%;">
</div>

<h3 id="2-方法2：排序"><a href="#2-方法2：排序" class="headerlink" title="2.方法2：排序"></a>2.方法2：排序</h3><p>我们可以先对数组 <code>nums</code> 进行排序，再返回最右边的 k 个元素，时间复杂度为 O(nlog⁡n) 。</p>
<p>显然，该方法“超额”完成任务了，因为我们只需找出最大的 k 个元素即可，而不需要排序其他元素。</p>
<div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/41.png" srcset="/img/loading.gif" lazyload alt="图片描述" style="zoom:60%;">
</div>

<h3 id="3-方法三：堆"><a href="#3-方法三：堆" class="headerlink" title="3. 方法三：堆"></a>3. 方法三：堆</h3><ol>
<li>初始化一个小顶堆，其堆顶元素最小。</li>
<li>先将数组的前 k 个元素依次入堆。</li>
<li>从第 k+1 个元素开始，若当前元素大于堆顶元素，则将堆顶元素出堆，并将当前元素入堆。</li>
<li>遍历完成后，堆中保存的就是最大的 k 个元素。</li>
</ol>
<div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/42.png" srcset="/img/loading.gif" lazyload alt="图片描述" style="zoom:35%;">
  <img src="/img/algorithm_pic/43.png" srcset="/img/loading.gif" lazyload alt="图片描述" style="zoom:35%;">
</div>

<div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/44.png" srcset="/img/loading.gif" lazyload alt="图片描述" style="zoom:35%;">
  <img src="/img/algorithm_pic/45.png" srcset="/img/loading.gif" lazyload alt="图片描述" style="zoom:35%;">
</div>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 基于堆查找数组中最大的 k 个元素 */</span><br>Queue&lt;Integer&gt; <span class="hljs-title function_">topKHeap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-comment">// 初始化小顶堆</span><br>    Queue&lt;Integer&gt; heap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;Integer&gt;();<br>    <span class="hljs-comment">// 将数组的前 k 个元素入堆</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>        heap.offer(nums[i]);<br>    &#125;<br>    <span class="hljs-comment">// 从第 k+1 个元素开始，保持堆的长度为 k</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-comment">// 若当前元素大于堆顶元素，则将堆顶元素出堆、当前元素入堆</span><br>        <span class="hljs-keyword">if</span> (nums[i] &gt; heap.peek()) &#123;<br>            heap.poll();<br>            heap.offer(nums[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> heap;<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="十、搜索"><a href="#十、搜索" class="headerlink" title="十、搜索"></a>十、搜索</h1><h2 id="2-二分查找"><a href="#2-二分查找" class="headerlink" title="2. 二分查找"></a>2. 二分查找</h2><p>二分查找算法也称折半查找，是一种非常高效的工作于有序数组的查找算法。后续的课程中还会学习更多的查找算法，但在此之前，不妨用它作为入门。</p>
<h3 id="1-需求说明"><a href="#1-需求说明" class="headerlink" title="1. 需求说明"></a>1. 需求说明</h3><div style="text-align:center;gap:5px">
    <img src="/img/algorithm_pic/2.png" srcset="/img/loading.gif" lazyload alt="图片描述">
</div>


<h3 id="2-java实现"><a href="#2-java实现" class="headerlink" title="2. java实现"></a>2. java实现</h3><h4 id="1-基础版（左闭右闭）"><a href="#1-基础版（左闭右闭）" class="headerlink" title="1. 基础版（左闭右闭）"></a>1. 基础版（左闭右闭）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Params：a - 待查找的升序数组</span><br><span class="hljs-comment">//        target - 待查找的目标值</span><br><span class="hljs-comment">// Returns：找到则返回值索引</span><br><span class="hljs-comment">//		    找不到返回 -1</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = a.length - <span class="hljs-number">1</span>;   <span class="hljs-comment">//设置前后的指针</span><br>    <span class="hljs-keyword">while</span> (i &lt;= j) &#123;           <span class="hljs-comment">// i-j范围内有东西</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> (i + j) &gt;&gt;&gt; <span class="hljs-number">1</span>;     <span class="hljs-comment">// 无符号右移，相当于除2后取整</span><br>        <span class="hljs-keyword">if</span> (target &lt; a[m]) &#123;			<span class="hljs-comment">// 目标值在左边</span><br>            j = m - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[m] &lt; target) &#123;		<span class="hljs-comment">// 目标值在右边</span><br>            i = m + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;                   <span class="hljs-comment">// 找到了</span><br>            <span class="hljs-keyword">return</span> m;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="2-进阶版（左闭右开）"><a href="#2-进阶版（左闭右开）" class="headerlink" title="2. 进阶版（左闭右开）"></a>2. 进阶版（左闭右开）</h4><p>左边指针只作为一个边界，不参与运算</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = a.length;   <br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;           <br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> (i + j) &gt;&gt;&gt; <span class="hljs-number">1</span>;     <br>        <span class="hljs-keyword">if</span> (target &lt; a[m]) &#123;			<br>            j = m ;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[m] &lt; target) &#123;		<br>            i = m + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;                   <br>            <span class="hljs-keyword">return</span> m;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="3-复杂度"><a href="#3-复杂度" class="headerlink" title="3. 复杂度"></a>3. 复杂度</h3><p>时间复杂度：用来衡量一个算法的执行，随数据规模增大，而增长的时间成本</p>
<ul>
<li><p>最坏情况：<code>O(log n)</code></p>
</li>
<li><p>最好情况：如果待查找元素恰好在数组中央，只需要循环一次 <code>O(1)</code></p>
</li>
</ul>
<p>空间复杂度：用来衡量一个算法执行随数据规模增大，而增长的<strong>额外</strong>空间成本</p>
<ul>
<li>需要常数个指针 <code>i,j,m</code>，因此额外占用的空间是 <code>O(1)</code></li>
</ul>
<h3 id="4-tips"><a href="#4-tips" class="headerlink" title="4. tips"></a>4. tips</h3><ol>
<li>无符号右移：<code>int m = (i + j) &gt;&gt;&gt; 1;</code>，底层原理是将十进制数字转为2进制数字，并将二进制数向右移动1位</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">偶数无符号右移</span> <span class="hljs-string">-&gt;</span> <span class="hljs-string">除2</span><br><span class="hljs-number">16</span>         <span class="hljs-bullet">-</span> <span class="hljs-number">0000 </span><span class="hljs-number">1000</span> <span class="hljs-bullet">-</span> <span class="hljs-number">16</span><br><span class="hljs-string">(16)</span> <span class="hljs-string">&gt;&gt;&gt;</span> <span class="hljs-number">1</span> <span class="hljs-bullet">-</span> <span class="hljs-number">0000 </span><span class="hljs-number">0100</span> <span class="hljs-bullet">-</span> <span class="hljs-number">8</span><br><br><span class="hljs-string">基数数无符号右移</span> <span class="hljs-string">-&gt;</span> <span class="hljs-string">除2-1</span><br><span class="hljs-number">9</span>         <span class="hljs-bullet">-</span> <span class="hljs-number">0000 </span><span class="hljs-number">0101</span> <span class="hljs-bullet">-</span> <span class="hljs-number">9</span><br><span class="hljs-string">(9)</span> <span class="hljs-string">&gt;&gt;&gt;</span> <span class="hljs-number">1</span> <span class="hljs-bullet">-</span> <span class="hljs-number">0000 </span><span class="hljs-number">0010</span> <span class="hljs-bullet">-</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>



<ol start="2">
<li>用<code>int m = (i + j) &gt;&gt;&gt; 1;</code>，而不用<code>int m = (i + j) / 2;</code>的原因，后者数字过大容易超出int限制出现负值</li>
</ol>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%BC%80%E5%8F%91/" class="category-chain-item">开发</a>
  
  
    <span>></span>
    
  <a href="/categories/%E5%BC%80%E5%8F%91/%E7%AE%97%E6%B3%95/" class="category-chain-item">算法</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%BC%80%E5%8F%91/" class="print-no-link">#开发</a>
      
        <a href="/tags/%E7%AE%97%E6%B3%95/" class="print-no-link">#算法</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>算法入门至精通</div>
      <div>http://example.com/2023/11/30/算法入门至精通/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>张辰</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年11月30日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/11/30/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/" title="Matplotlib+Numpy+Pandas数据分析">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Matplotlib+Numpy+Pandas数据分析</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/11/30/%E7%BB%AD%E8%88%AA%E6%B5%8B%E8%AF%95/" title="续航测试方法">
                        <span class="hidden-mobile">续航测试方法</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  



  <script>
  Fluid.utils.createScript('https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js', function() {
    mermaid.initialize({"theme":"default"});

    Fluid.utils.listenDOMLoaded(function() {
      Fluid.events.registerRefreshCallback(function() {
        if ('mermaid' in window) {
          mermaid.init();
        }
      });
    });
  });
</script>






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量
        <span id="busuanzi_value_site_pv"></span>
        次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数
        <span id="busuanzi_value_site_uv"></span>
        人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
